{"version":3,"file":"a9b74ab3.js","mappings":";;;;AAmGA;AACA;AACA;AACA;;;AAIA;AACA;;;;AAIA;;;;;;AAMA;;;;;;AAOA;;;;;;AC5GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACoFA;AC9CA;AACA;AACA;;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA;;ACqDA;;AAYA;;AA+CA;AAKA;;AAEA;;;AAKA;AAKA;AACA;AACA;;;AAGA;;;;;AAKA;;AAIA;;AAKA;AAGA;AACA;AACA;;;;;AAMA;;;;AAQA;;;;;AAKA;AAEA;AAKA;AACA;;;;AA9RA;;;;;;AA4SA;AACA;;;;AAIA;;;AAKA;;;AAKA;;AAIA;;;AAIA;;;;AAWA;;;;AA9UA;;;;;AA0VA;AACA;AACA;;AAEA;;AAEA;;AAGA;AACA;AACA;AACA;;AAEA;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmWA;;;;AChoBA;;;AAIA;;AAEA;;AAGA;AACA;;;;AAIA;;;AAOA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;AAyKA","sources":["webpack://home-assistant-frontend/mwc-linear-progress-base.ts","webpack://home-assistant-frontend/./src/components/ha-button.ts","webpack://home-assistant-frontend/./src/layouts/ha-app-layout.js","webpack://home-assistant-frontend/./src/panels/lovelace/components/hui-marquee.ts","webpack://home-assistant-frontend/./src/panels/media-browser/ha-bar-media-player.ts","webpack://home-assistant-frontend/./src/panels/media-browser/ha-panel-media-browser.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport {MDCResizeObserver, WithMDCResizeObserver} from '@material/linear-progress/types.js';\nimport {ariaProperty} from '@material/mwc-base/aria-property.js';\nimport {html, LitElement, PropertyValues, TemplateResult} from 'lit';\nimport {property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\n/** @soyCompatible */\nexport class LinearProgressBase extends LitElement {\n  @query('.mdc-linear-progress') protected rootEl!: HTMLElement;\n\n  @property({type: Boolean, reflect: true}) indeterminate = false;\n\n  @property({type: Number}) progress = 0;\n\n  @property({type: Number}) buffer = 1;\n\n  @property({type: Boolean, reflect: true}) reverse = false;\n\n  @property({type: Boolean, reflect: true}) closed = false;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({attribute: 'aria-label'})\n  override ariaLabel!: string;\n\n  @state() protected stylePrimaryHalf = '';\n  @state() protected stylePrimaryFull = '';\n  @state() protected styleSecondaryQuarter = '';\n  @state() protected styleSecondaryHalf = '';\n  @state() protected styleSecondaryFull = '';\n  @state() protected animationReady = true;\n  @state() protected closedAnimationOff = false;\n  protected resizeObserver: MDCResizeObserver|null = null;\n\n  override connectedCallback() {\n    super.connectedCallback();\n    // if detached and reattached\n    if (this.rootEl) {\n      this.attachResizeObserver();\n    }\n  }\n\n  /**\n   * @soyTemplate\n   */\n  protected override render(): TemplateResult {\n    /** @classMap */\n    const classes = {\n      'mdc-linear-progress--closed': this.closed,\n      'mdc-linear-progress--closed-animation-off': this.closedAnimationOff,\n      'mdc-linear-progress--indeterminate': this.indeterminate,\n      // needed for controller-less render\n      'mdc-linear-progress--animation-ready': this.animationReady\n    };\n\n    /** @styleMap */\n    const rootStyles = {\n      '--mdc-linear-progress-primary-half': this.stylePrimaryHalf,\n      '--mdc-linear-progress-primary-half-neg':\n          this.stylePrimaryHalf !== '' ? `-${this.stylePrimaryHalf}` : '',\n      '--mdc-linear-progress-primary-full': this.stylePrimaryFull,\n      '--mdc-linear-progress-primary-full-neg':\n          this.stylePrimaryFull !== '' ? `-${this.stylePrimaryFull}` : '',\n      '--mdc-linear-progress-secondary-quarter': this.styleSecondaryQuarter,\n      '--mdc-linear-progress-secondary-quarter-neg':\n          this.styleSecondaryQuarter !== '' ? `-${this.styleSecondaryQuarter}` :\n                                              '',\n      '--mdc-linear-progress-secondary-half': this.styleSecondaryHalf,\n      '--mdc-linear-progress-secondary-half-neg':\n          this.styleSecondaryHalf !== '' ? `-${this.styleSecondaryHalf}` : '',\n      '--mdc-linear-progress-secondary-full': this.styleSecondaryFull,\n      '--mdc-linear-progress-secondary-full-neg':\n          this.styleSecondaryFull !== '' ? `-${this.styleSecondaryFull}` : '',\n    };\n\n    /** @styleMap */\n    const bufferBarStyles = {\n      'flex-basis': this.indeterminate ? '100%' : `${this.buffer * 100}%`,\n    };\n\n    /** @styleMap */\n    const primaryBarStyles = {\n      transform: this.indeterminate ? 'scaleX(1)' : `scaleX(${this.progress})`,\n    };\n\n    return html`\n      <div\n          role=\"progressbar\"\n          class=\"mdc-linear-progress ${classMap(classes)}\"\n          style=\"${styleMap(rootStyles)}\"\n          dir=\"${ifDefined(this.reverse ? 'rtl' : undefined)}\"\n          aria-label=\"${ifDefined(this.ariaLabel)}\"\n          aria-valuemin=\"0\"\n          aria-valuemax=\"1\"\n          aria-valuenow=\"${\n        ifDefined(this.indeterminate ? undefined : this.progress)}\"\n        @transitionend=\"${this.syncClosedState}\">\n        <div class=\"mdc-linear-progress__buffer\">\n          <div\n            class=\"mdc-linear-progress__buffer-bar\"\n            style=${styleMap(bufferBarStyles)}>\n          </div>\n          <div class=\"mdc-linear-progress__buffer-dots\"></div>\n        </div>\n        <div\n            class=\"mdc-linear-progress__bar mdc-linear-progress__primary-bar\"\n            style=${styleMap(primaryBarStyles)}>\n          <span class=\"mdc-linear-progress__bar-inner\"></span>\n        </div>\n        <div class=\"mdc-linear-progress__bar mdc-linear-progress__secondary-bar\">\n          <span class=\"mdc-linear-progress__bar-inner\"></span>\n        </div>\n      </div>`;\n  }\n\n  override update(changedProperties: PropertyValues<this>) {\n    // - When showing the indicator, enable animations immediately.\n    // - On first render, disable the animation immediately.\n    // - For normal calls to hide the component, let transitionend event trigger\n    //   disabling of animations instead (see render method), so that animation\n    //   does not jump in the middle of fade out.\n    if (changedProperties.has('closed') &&\n        (!this.closed || changedProperties.get('closed') === undefined)) {\n      this.syncClosedState();\n    }\n    super.update(changedProperties);\n  }\n\n  override async firstUpdated(changed: PropertyValues<this>) {\n    super.firstUpdated(changed);\n\n    this.attachResizeObserver();\n  }\n\n  protected syncClosedState() {\n    this.closedAnimationOff = this.closed;\n  }\n\n  protected override updated(changed: PropertyValues<this>) {\n    // restart animation for timing if reverse changed and is indeterminate.\n    // don't restart here if indeterminate has changed as well because we don't\n    // want to incur an extra style recalculation\n    if (!changed.has('indeterminate') && changed.has('reverse') &&\n        this.indeterminate) {\n      this.restartAnimation();\n    }\n\n    // Recaclulate the animation css custom props and restart the calculation\n    // if this is not the first render cycle, otherwise, resize observer init\n    // will already handle this and prevent unnecessary rerender + style recalc\n    // but resize observer will not update animation vals while determinate\n    if (changed.has('indeterminate') &&\n        changed.get('indeterminate') !== undefined && this.indeterminate &&\n        (window as unknown as WithMDCResizeObserver).ResizeObserver) {\n      this.calculateAndSetAnimationDimensions(this.rootEl.offsetWidth);\n    }\n    super.updated(changed);\n  }\n\n  override disconnectedCallback() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    super.disconnectedCallback();\n  }\n\n  protected attachResizeObserver() {\n    if ((window as unknown as WithMDCResizeObserver).ResizeObserver) {\n      this.resizeObserver =\n          new (window as unknown as WithMDCResizeObserver)\n              .ResizeObserver((entries) => {\n                if (!this.indeterminate) {\n                  return;\n                }\n\n                for (const entry of entries) {\n                  if (entry.contentRect) {\n                    const width = entry.contentRect.width;\n                    this.calculateAndSetAnimationDimensions(width);\n                  }\n                }\n              });\n      this.resizeObserver.observe(this.rootEl);\n      return;\n    }\n\n    this.resizeObserver = null;\n  }\n\n  protected calculateAndSetAnimationDimensions(width: number) {\n    const primaryHalf = width * 0.8367142;\n    const primaryFull = width * 2.00611057;\n    const secondaryQuarter = width * 0.37651913;\n    const secondaryHalf = width * 0.84386165;\n    const secondaryFull = width * 1.60277782;\n\n    this.stylePrimaryHalf = `${primaryHalf}px`;\n    this.stylePrimaryFull = `${primaryFull}px`;\n    this.styleSecondaryQuarter = `${secondaryQuarter}px`;\n    this.styleSecondaryHalf = `${secondaryHalf}px`;\n    this.styleSecondaryFull = `${secondaryFull}px`;\n\n    // need to restart animation for custom props to apply to keyframes\n    this.restartAnimation();\n  }\n\n  protected async restartAnimation() {\n    this.animationReady = false;\n    await this.updateComplete;\n    await new Promise(requestAnimationFrame);\n    this.animationReady = true;\n    await this.updateComplete;\n  }\n\n  open() {\n    this.closed = false;\n  }\n\n  close() {\n    this.closed = true;\n  }\n}\n","import { Button } from \"@material/mwc-button\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\nimport { styles } from \"@material/mwc-button/styles.css\";\n\n@customElement(\"ha-button\")\nexport class HaButton extends Button {\n  static override styles = [\n    styles,\n    css`\n      ::slotted([slot=\"icon\"]) {\n        margin-inline-start: 0px;\n        margin-inline-end: 8px;\n        direction: var(--direction);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button\": HaButton;\n  }\n}\n","/* eslint-plugin-disable lit */\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\nThis code is copied from app-header-layout.\n'fullbleed' support is removed as Home Assisstant doesn't use it.\ntransform: translate(0) is added.\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\nimport \"@polymer/polymer/polymer-element\";\n\nclass HaAppLayout extends customElements.get(\"app-header-layout\") {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n          position: relative;\n          z-index: 0;\n        }\n\n        #wrapper ::slotted([slot=\"header\"]) {\n          @apply --layout-fixed-top;\n          z-index: 1;\n        }\n\n        #wrapper.initializing ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) {\n          height: 100%;\n        }\n\n        :host([has-scrolling-region]) #wrapper ::slotted([slot=\"header\"]) {\n          position: absolute;\n        }\n\n        :host([has-scrolling-region])\n          #wrapper.initializing\n          ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          @apply --layout-fit;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n\n        :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n          position: relative;\n        }\n\n        #contentContainer {\n          /* Create a stacking context here so that all children appear below the header. */\n          position: relative;\n          z-index: 0;\n          /* Using 'transform' will cause 'position: fixed' elements to behave like\n           'position: absolute' relative to this element. */\n          transform: translate(0);\n          margin-left: env(safe-area-inset-left);\n          margin-right: env(safe-area-inset-right);\n          padding-top: env(safe-area-inset-top);\n          padding-bottom: env(safe-area-inset-bottom);\n        }\n\n        @media print {\n          :host([has-scrolling-region]) #wrapper #contentContainer {\n            overflow-y: visible;\n          }\n        }\n      </style>\n\n      <div id=\"wrapper\" class=\"initializing\">\n        <slot id=\"headerSlot\" name=\"header\"></slot>\n\n        <div id=\"contentContainer\"><slot></slot></div>\n        <slot id=\"fab\" name=\"fab\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"ha-app-layout\", HaAppLayout);\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"hui-marquee\")\nclass HuiMarquee extends LitElement {\n  @property() public text?: string;\n\n  @property({ type: Boolean }) public active?: boolean;\n\n  @property({ reflect: true, type: Boolean, attribute: \"animating\" })\n  private _animating = false;\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n\n    // eslint-disable-next-line wc/no-self-class\n    this.addEventListener(\"mouseover\", () => this.classList.add(\"hovering\"), {\n      // Capture because we need to run before a parent sets active on us.\n      // Hovering will disable the overflow, allowing us to calc if we overflow.\n      capture: true,\n    });\n    // eslint-disable-next-line wc/no-self-class\n    this.addEventListener(\"mouseout\", () => this.classList.remove(\"hovering\"));\n  }\n\n  protected updated(changedProperties: PropertyValues): void {\n    super.updated(changedProperties);\n\n    if (changedProperties.has(\"text\") && this._animating) {\n      this._animating = false;\n    }\n\n    if (\n      changedProperties.has(\"active\") &&\n      this.active &&\n      this.offsetWidth < this.scrollWidth\n    ) {\n      this._animating = true;\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.text) {\n      return html``;\n    }\n\n    return html`\n      <div class=\"marquee-inner\" @animationiteration=${this._onIteration}>\n        <span>${this.text}</span>\n        ${this._animating ? html` <span>${this.text}</span> ` : \"\"}\n      </div>\n    `;\n  }\n\n  private _onIteration() {\n    if (!this.active) {\n      this._animating = false;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex;\n        position: relative;\n        align-items: center;\n        height: 1.2em;\n        contain: strict;\n      }\n\n      .marquee-inner {\n        position: absolute;\n        left: 0;\n        right: 0;\n        text-overflow: ellipsis;\n        overflow: hidden;\n      }\n\n      :host(.hovering) .marquee-inner {\n        text-overflow: initial;\n        overflow: initial;\n      }\n\n      :host([animating]) .marquee-inner {\n        left: initial;\n        right: initial;\n        animation: marquee 10s linear infinite;\n      }\n\n      :host([animating]) .marquee-inner span {\n        padding-right: 16px;\n      }\n\n      @keyframes marquee {\n        0% {\n          transform: translateX(0%);\n        }\n        100% {\n          transform: translateX(-50%);\n        }\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-marquee\": HuiMarquee;\n  }\n}\n","import \"@material/mwc-button/mwc-button\";\nimport \"@material/mwc-linear-progress/mwc-linear-progress\";\nimport type { LinearProgress } from \"@material/mwc-linear-progress/mwc-linear-progress\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport {\n  mdiChevronDown,\n  mdiMonitor,\n  mdiPause,\n  mdiPlay,\n  mdiPlayPause,\n  mdiStop,\n  mdiVolumeHigh,\n} from \"@mdi/js\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { until } from \"lit/directives/until\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { domainIcon } from \"../../common/entity/domain_icon\";\nimport { supportsFeature } from \"../../common/entity/supports-feature\";\nimport \"../../components/ha-button\";\nimport \"../../components/ha-button-menu\";\nimport \"../../components/ha-circular-progress\";\nimport \"../../components/ha-icon-button\";\nimport { UNAVAILABLE } from \"../../data/entity\";\nimport { subscribeEntityRegistry } from \"../../data/entity_registry\";\nimport {\n  BROWSER_PLAYER,\n  cleanupMediaTitle,\n  computeMediaControls,\n  computeMediaDescription,\n  ControlButton,\n  formatMediaTime,\n  getCurrentProgress,\n  handleMediaControlClick,\n  MediaPlayerEntity,\n  MediaPlayerEntityFeature,\n  MediaPlayerItem,\n  setMediaPlayerVolume,\n} from \"../../data/media-player\";\nimport { ResolvedMediaSource } from \"../../data/media_source\";\nimport { showAlertDialog } from \"../../dialogs/generic/show-dialog-box\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../lovelace/components/hui-marquee\";\nimport {\n  BrowserMediaPlayer,\n  ERR_UNSUPPORTED_MEDIA,\n} from \"./browser-media-player\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"player-picked\": { entityId: string };\n  }\n}\n\n@customElement(\"ha-bar-media-player\")\nexport class BarMediaPlayer extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entityId!: string;\n\n  @property({ type: Boolean, reflect: true })\n  public narrow!: boolean;\n\n  @query(\"mwc-linear-progress\") private _progressBar?: LinearProgress;\n\n  @query(\"#CurrentProgress\") private _currentProgress?: HTMLElement;\n\n  @state() private _marqueeActive = false;\n\n  @state() private _newMediaExpected = false;\n\n  @state() private _browserPlayer?: BrowserMediaPlayer;\n\n  @state()\n  private _hiddenEntities = new Set<string>();\n\n  private _progressInterval?: number;\n\n  private _browserPlayerVolume = 0.8;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n\n    const stateObj = this._stateObj;\n\n    if (!stateObj) {\n      return;\n    }\n\n    if (\n      !this._progressInterval &&\n      this._showProgressBar &&\n      stateObj.state === \"playing\"\n    ) {\n      this._progressInterval = window.setInterval(\n        () => this._updateProgressBar(),\n        1000\n      );\n    }\n  }\n\n  public disconnectedCallback(): void {\n    if (this._progressInterval) {\n      clearInterval(this._progressInterval);\n      this._progressInterval = undefined;\n    }\n    this._tearDownBrowserPlayer();\n  }\n\n  public showResolvingNewMediaPicked() {\n    this._tearDownBrowserPlayer();\n    this._newMediaExpected = true;\n  }\n\n  public hideResolvingNewMediaPicked() {\n    this._newMediaExpected = false;\n  }\n\n  public playItem(item: MediaPlayerItem, resolved: ResolvedMediaSource) {\n    if (this.entityId !== BROWSER_PLAYER) {\n      throw Error(\"Only browser supported\");\n    }\n    this._tearDownBrowserPlayer();\n    try {\n      this._browserPlayer = new BrowserMediaPlayer(\n        this.hass,\n        item,\n        resolved,\n        this._browserPlayerVolume,\n        () => this.requestUpdate(\"_browserPlayer\")\n      );\n    } catch (err: any) {\n      if (err.message === ERR_UNSUPPORTED_MEDIA) {\n        showAlertDialog(this, {\n          text: this.hass.localize(\n            \"ui.components.media-browser.media_not_supported\"\n          ),\n        });\n      } else {\n        throw err;\n      }\n    }\n    this._newMediaExpected = false;\n  }\n\n  protected render(): TemplateResult {\n    if (this._newMediaExpected) {\n      return html`\n        <div class=\"controls-progress\">\n          ${until(\n            // Only show spinner after 500ms\n            new Promise((resolve) => {\n              setTimeout(resolve, 500);\n            }).then(\n              () => html`<ha-circular-progress active></ha-circular-progress>`\n            )\n          )}\n        </div>\n      `;\n    }\n\n    const isBrowser = this.entityId === BROWSER_PLAYER;\n    const stateObj = this._stateObj;\n\n    if (!stateObj) {\n      return this._renderChoosePlayer(stateObj);\n    }\n\n    const controls: ControlButton[] | undefined = !this.narrow\n      ? computeMediaControls(stateObj, true)\n      : (stateObj.state === \"playing\" &&\n          (supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE) ||\n            supportsFeature(stateObj, MediaPlayerEntityFeature.STOP))) ||\n        ((stateObj.state === \"paused\" || stateObj.state === \"idle\") &&\n          supportsFeature(stateObj, MediaPlayerEntityFeature.PLAY)) ||\n        (stateObj.state === \"on\" &&\n          (supportsFeature(stateObj, MediaPlayerEntityFeature.PLAY) ||\n            supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE)))\n      ? [\n          {\n            icon:\n              stateObj.state === \"on\"\n                ? mdiPlayPause\n                : stateObj.state !== \"playing\"\n                ? mdiPlay\n                : supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE)\n                ? mdiPause\n                : mdiStop,\n            action:\n              stateObj.state !== \"playing\"\n                ? \"media_play\"\n                : supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE)\n                ? \"media_pause\"\n                : \"media_stop\",\n          },\n        ]\n      : undefined;\n    const mediaDescription = computeMediaDescription(stateObj);\n    const mediaDuration = formatMediaTime(stateObj.attributes.media_duration);\n    const mediaTitleClean = cleanupMediaTitle(\n      stateObj.attributes.media_title || stateObj.attributes.media_content_id\n    );\n    const mediaArt =\n      stateObj.attributes.entity_picture_local ||\n      stateObj.attributes.entity_picture;\n\n    return html`\n      <div\n        class=${classMap({\n          info: true,\n          pointer: !isBrowser,\n          app: this._browserPlayer?.item.media_class === \"app\",\n        })}\n        @click=${this._openMoreInfo}\n      >\n        ${mediaArt\n          ? html`<img alt=\"\" src=${this.hass.hassUrl(mediaArt)} />`\n          : \"\"}\n        <div class=\"media-info\">\n          <hui-marquee\n            .text=${mediaTitleClean ||\n            mediaDescription ||\n            (stateObj.state !== \"playing\" && stateObj.state !== \"on\"\n              ? this.hass.localize(`ui.card.media_player.nothing_playing`)\n              : \"\")}\n            .active=${this._marqueeActive}\n            @mouseover=${this._marqueeMouseOver}\n            @mouseleave=${this._marqueeMouseLeave}\n          ></hui-marquee>\n          <span class=\"secondary\">\n            ${mediaTitleClean ? mediaDescription : \"\"}\n          </span>\n        </div>\n      </div>\n      <div class=\"controls-progress\">\n        ${stateObj.state === \"buffering\"\n          ? html` <ha-circular-progress active></ha-circular-progress> `\n          : html`\n              <div class=\"controls\">\n                ${controls === undefined\n                  ? \"\"\n                  : controls.map(\n                      (control) => html`\n                        <ha-icon-button\n                          .label=${this.hass.localize(\n                            `ui.card.media_player.${control.action}`\n                          )}\n                          .path=${control.icon}\n                          action=${control.action}\n                          @click=${this._handleControlClick}\n                        >\n                        </ha-icon-button>\n                      `\n                    )}\n              </div>\n              ${stateObj.attributes.media_duration === Infinity\n                ? html``\n                : this.narrow\n                ? html`<mwc-linear-progress></mwc-linear-progress>`\n                : html`\n                    <div class=\"progress\">\n                      <div id=\"CurrentProgress\"></div>\n                      <mwc-linear-progress wide></mwc-linear-progress>\n                      <div>${mediaDuration}</div>\n                    </div>\n                  `}\n            `}\n      </div>\n      ${this._renderChoosePlayer(stateObj)}\n    `;\n  }\n\n  private _renderChoosePlayer(stateObj: MediaPlayerEntity | undefined) {\n    const isBrowser = this.entityId === BROWSER_PLAYER;\n    return html`\n    <div class=\"choose-player ${isBrowser ? \"browser\" : \"\"}\">\n      ${\n        !this.narrow &&\n        stateObj &&\n        supportsFeature(stateObj, MediaPlayerEntityFeature.VOLUME_SET)\n          ? html`\n              <ha-button-menu corner=\"BOTTOM_START\" y=\"0\" x=\"76\">\n                <ha-icon-button\n                  slot=\"trigger\"\n                  .path=${mdiVolumeHigh}\n                ></ha-icon-button>\n                <ha-slider\n                  min=\"0\"\n                  max=\"100\"\n                  step=\"1\"\n                  .value=${stateObj.attributes.volume_level! * 100}\n                  @change=${this._handleVolumeChange}\n                >\n                </ha-slider>\n              </ha-button-menu>\n            `\n          : \"\"\n      }\n\n          <ha-button-menu corner=\"BOTTOM_START\">\n            ${\n              this.narrow\n                ? html`\n                    <ha-icon-button\n                      slot=\"trigger\"\n                      .path=${isBrowser\n                        ? mdiMonitor\n                        : domainIcon(computeDomain(this.entityId), stateObj)}\n                    ></ha-icon-button>\n                  `\n                : html`\n                    <ha-button\n                      slot=\"trigger\"\n                      .label=${this.narrow\n                        ? \"\"\n                        : `${\n                            stateObj\n                              ? computeStateName(stateObj)\n                              : this.entityId\n                          }\n                `}\n                    >\n                      <ha-svg-icon\n                        slot=\"icon\"\n                        .path=${isBrowser\n                          ? mdiMonitor\n                          : domainIcon(computeDomain(this.entityId), stateObj)}\n                      ></ha-svg-icon>\n                      <ha-svg-icon\n                        slot=\"trailingIcon\"\n                        .path=${mdiChevronDown}\n                      ></ha-svg-icon>\n                    </ha-button>\n                  `\n            }\n            <mwc-list-item\n              .player=${BROWSER_PLAYER}\n              ?selected=${isBrowser}\n              @click=${this._selectPlayer}\n            >\n              ${this.hass.localize(\"ui.components.media-browser.web-browser\")}\n            </mwc-list-item>\n            ${this._mediaPlayerEntities.map(\n              (source) => html`\n                <mwc-list-item\n                  ?selected=${source.entity_id === this.entityId}\n                  .disabled=${source.state === UNAVAILABLE}\n                  .player=${source.entity_id}\n                  @click=${this._selectPlayer}\n                >\n                  ${computeStateName(source)}\n                </mwc-list-item>\n              `\n            )}\n          </ha-button-menu>\n        </div>\n      </div>\n\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"entityId\")) {\n      this._tearDownBrowserPlayer();\n    }\n    if (!changedProps.has(\"hass\") || this.entityId === BROWSER_PLAYER) {\n      return;\n    }\n    // Reset new media expected if media player state changes\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    if (\n      !oldHass ||\n      oldHass.states[this.entityId] !== this.hass.states[this.entityId]\n    ) {\n      this._newMediaExpected = false;\n    }\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    if (this.entityId === BROWSER_PLAYER) {\n      if (!changedProps.has(\"_browserPlayer\")) {\n        return;\n      }\n    } else {\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n      if (oldHass && oldHass.states[this.entityId] === this._stateObj) {\n        return;\n      }\n    }\n\n    const stateObj = this._stateObj;\n\n    this._updateProgressBar();\n\n    if (\n      !this._progressInterval &&\n      this._showProgressBar &&\n      stateObj?.state === \"playing\"\n    ) {\n      this._progressInterval = window.setInterval(\n        () => this._updateProgressBar(),\n        1000\n      );\n    } else if (\n      this._progressInterval &&\n      (!this._showProgressBar || stateObj?.state !== \"playing\")\n    ) {\n      clearInterval(this._progressInterval);\n      this._progressInterval = undefined;\n    }\n  }\n\n  private get _stateObj(): MediaPlayerEntity | undefined {\n    if (this.entityId === BROWSER_PLAYER) {\n      return this._browserPlayer\n        ? this._browserPlayer.toStateObj()\n        : BrowserMediaPlayer.idleStateObj();\n    }\n    return this.hass!.states[this.entityId] as MediaPlayerEntity | undefined;\n  }\n\n  private _tearDownBrowserPlayer() {\n    if (this._browserPlayer) {\n      this._browserPlayer.remove();\n      this._browserPlayer = undefined;\n    }\n  }\n\n  private _openMoreInfo() {\n    if (this._browserPlayer) {\n      return;\n    }\n    fireEvent(this, \"hass-more-info\", { entityId: this.entityId });\n  }\n\n  private get _showProgressBar() {\n    if (!this.hass) {\n      return false;\n    }\n\n    const stateObj = this._stateObj;\n\n    return (\n      stateObj &&\n      (stateObj.state === \"playing\" || stateObj.state === \"paused\") &&\n      \"media_duration\" in stateObj.attributes &&\n      \"media_position\" in stateObj.attributes\n    );\n  }\n\n  private get _mediaPlayerEntities() {\n    return Object.values(this.hass!.states).filter(\n      (entity) =>\n        computeStateDomain(entity) === \"media_player\" &&\n        supportsFeature(entity, MediaPlayerEntityFeature.BROWSE_MEDIA) &&\n        !this._hiddenEntities.has(entity.entity_id)\n    );\n  }\n\n  private _updateProgressBar(): void {\n    const stateObj = this._stateObj;\n\n    if (!this._progressBar || !this._currentProgress || !stateObj) {\n      return;\n    }\n\n    if (!stateObj.attributes.media_duration) {\n      this._progressBar.progress = 0;\n      this._currentProgress.innerHTML = \"\";\n      return;\n    }\n\n    const currentProgress = getCurrentProgress(stateObj);\n    this._progressBar.progress =\n      currentProgress / stateObj.attributes.media_duration;\n\n    if (this._currentProgress) {\n      this._currentProgress.innerHTML = formatMediaTime(currentProgress);\n    }\n  }\n\n  protected override hassSubscribe(): (\n    | UnsubscribeFunc\n    | Promise<UnsubscribeFunc>\n  )[] {\n    return [\n      subscribeEntityRegistry(this.hass.connection, (entries) => {\n        const hiddenEntities = new Set<string>();\n\n        for (const entry of entries) {\n          if (\n            entry.hidden_by &&\n            computeDomain(entry.entity_id) === \"media_player\"\n          ) {\n            hiddenEntities.add(entry.entity_id);\n          }\n        }\n\n        this._hiddenEntities = hiddenEntities;\n      }),\n    ];\n  }\n\n  private _handleControlClick(e: MouseEvent): void {\n    const action = (e.currentTarget! as HTMLElement).getAttribute(\"action\")!;\n\n    if (!this._browserPlayer) {\n      handleMediaControlClick(\n        this.hass!,\n        this._stateObj!,\n        (e.currentTarget as HTMLElement).getAttribute(\"action\")!\n      );\n      return;\n    }\n    if (action === \"media_pause\") {\n      this._browserPlayer.pause();\n    } else if (action === \"media_play\") {\n      this._browserPlayer.play();\n    }\n  }\n\n  private _marqueeMouseOver(): void {\n    if (!this._marqueeActive) {\n      this._marqueeActive = true;\n    }\n  }\n\n  private _marqueeMouseLeave(): void {\n    if (this._marqueeActive) {\n      this._marqueeActive = false;\n    }\n  }\n\n  private _selectPlayer(ev: CustomEvent): void {\n    const entityId = (ev.currentTarget as any).player;\n    fireEvent(this, \"player-picked\", { entityId });\n  }\n\n  private async _handleVolumeChange(ev) {\n    ev.stopPropagation();\n    const value = Number(ev.target.value) / 100;\n    if (this._browserPlayer) {\n      this._browserPlayerVolume = value;\n      this._browserPlayer.setVolume(value);\n    } else {\n      await setMediaPlayerVolume(this.hass, this.entityId, value);\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex;\n        min-height: 100px;\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        border-top: 1px solid var(--divider-color);\n        padding-bottom: env(safe-area-inset-bottom);\n      }\n\n      mwc-linear-progress {\n        width: 100%;\n        padding: 0 4px;\n        --mdc-theme-primary: var(--secondary-text-color);\n      }\n\n      mwc-button[slot=\"trigger\"] {\n        --mdc-theme-primary: var(--primary-text-color);\n        --mdc-icon-size: 36px;\n      }\n\n      .info {\n        flex: 1;\n        display: flex;\n        align-items: center;\n        width: 100%;\n        margin-right: 16px;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n      }\n\n      .pointer {\n        cursor: pointer;\n      }\n\n      .secondary,\n      .progress {\n        color: var(--secondary-text-color);\n      }\n\n      .choose-player {\n        flex: 1;\n        display: flex;\n        justify-content: flex-end;\n        align-items: center;\n        padding: 16px;\n      }\n\n      .controls {\n        height: 48px;\n        padding-bottom: 4px;\n      }\n\n      .controls-progress {\n        flex: 2;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        direction: ltr;\n      }\n\n      .progress {\n        display: flex;\n        width: 100%;\n        align-items: center;\n      }\n\n      mwc-linear-progress[wide] {\n        margin: 0 4px;\n      }\n\n      .media-info {\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n        padding-left: 16px;\n        width: 100%;\n      }\n\n      hui-marquee {\n        font-size: 1.2em;\n        margin: 0px 0 4px;\n      }\n\n      img {\n        max-height: 100px;\n        max-width: 100px;\n      }\n\n      .app img {\n        max-height: 68px;\n        margin: 16px 0 16px 16px;\n      }\n\n      ha-button-menu mwc-button {\n        line-height: 1;\n      }\n\n      :host([narrow]) {\n        min-height: 56px;\n        max-height: 56px;\n      }\n\n      :host([narrow]) .controls-progress {\n        flex: unset;\n        min-width: 48px;\n      }\n\n      :host([narrow]) .media-info {\n        padding-left: 8px;\n      }\n\n      :host([narrow]) .controls {\n        display: flex;\n        padding-bottom: 0;\n        --mdc-icon-size: 30px;\n      }\n\n      :host([narrow]) .choose-player {\n        padding-left: 0;\n        padding-right: 8px;\n        min-width: 48px;\n        flex: unset;\n        justify-content: center;\n      }\n\n      :host([narrow]) .choose-player.browser {\n        justify-content: flex-end;\n      }\n\n      :host([narrow]) img {\n        max-height: 56px;\n        max-width: 56px;\n      }\n\n      :host([narrow]) .blank-image {\n        height: 56px;\n        width: 56px;\n      }\n\n      :host([narrow]) mwc-linear-progress {\n        padding: 0;\n        position: absolute;\n        top: -4px;\n        left: 0;\n      }\n\n      mwc-list-item[selected] {\n        font-weight: bold;\n      }\n\n      ha-svg-icon[slot=\"trailingIcon\"] {\n        margin-inline-start: 8px !important;\n        margin-inline-end: 0px !important;\n        direction: var(--direction);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-bar-media-player\": BarMediaPlayer;\n  }\n}\n","import { mdiArrowLeft } from \"@mdi/js\";\nimport \"@polymer/app-layout/app-header/app-header\";\nimport \"@polymer/app-layout/app-toolbar/app-toolbar\";\nimport \"@material/mwc-button\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { LocalStorage } from \"../../common/decorators/local-storage\";\nimport { fireEvent, HASSDomEvent } from \"../../common/dom/fire_event\";\nimport { navigate } from \"../../common/navigate\";\nimport \"../../components/ha-menu-button\";\nimport \"../../components/ha-icon-button\";\nimport \"../../components/ha-icon-button-arrow-prev\";\nimport \"../../components/media-player/ha-media-player-browse\";\nimport \"../../components/media-player/ha-media-manage-button\";\nimport type {\n  HaMediaPlayerBrowse,\n  MediaPlayerItemId,\n} from \"../../components/media-player/ha-media-player-browse\";\nimport {\n  BROWSER_PLAYER,\n  MediaPickedEvent,\n  MediaPlayerItem,\n  mediaPlayerPlayMedia,\n} from \"../../data/media-player\";\nimport {\n  ResolvedMediaSource,\n  resolveMediaSource,\n} from \"../../data/media_source\";\nimport \"../../layouts/ha-app-layout\";\nimport { haStyle } from \"../../resources/styles\";\nimport type { HomeAssistant, Route } from \"../../types\";\nimport \"./ha-bar-media-player\";\nimport type { BarMediaPlayer } from \"./ha-bar-media-player\";\nimport { showWebBrowserPlayMediaDialog } from \"./show-media-player-dialog\";\nimport { showAlertDialog } from \"../../dialogs/generic/show-dialog-box\";\nimport {\n  getEntityIdFromCameraMediaSource,\n  isCameraMediaSource,\n} from \"../../data/camera\";\n\nconst createMediaPanelUrl = (entityId: string, items: MediaPlayerItemId[]) => {\n  let path = `/media-browser/${entityId}`;\n  for (const item of items.slice(1)) {\n    path +=\n      \"/\" +\n      encodeURIComponent(`${item.media_content_type},${item.media_content_id}`);\n  }\n  return path;\n};\n\n@customElement(\"ha-panel-media-browser\")\nclass PanelMediaBrowser extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true })\n  public narrow!: boolean;\n\n  @property() public route!: Route;\n\n  @state() _currentItem?: MediaPlayerItem;\n\n  private _navigateIds: MediaPlayerItemId[] = [\n    {\n      media_content_id: undefined,\n      media_content_type: undefined,\n    },\n  ];\n\n  @LocalStorage(\"mediaBrowseEntityId\", true, false)\n  private _entityId = BROWSER_PLAYER;\n\n  @query(\"ha-media-player-browse\") private _browser!: HaMediaPlayerBrowse;\n\n  @query(\"ha-bar-media-player\") private _player!: BarMediaPlayer;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-app-layout>\n        <app-header fixed slot=\"header\">\n          <app-toolbar>\n            ${this._navigateIds.length > 1\n              ? html`\n                  <ha-icon-button-arrow-prev\n                    .path=${mdiArrowLeft}\n                    @click=${this._goBack}\n                  ></ha-icon-button-arrow-prev>\n                `\n              : html`\n                  <ha-menu-button\n                    .hass=${this.hass}\n                    .narrow=${this.narrow}\n                  ></ha-menu-button>\n                `}\n            <div main-title>\n              ${!this._currentItem\n                ? this.hass.localize(\n                    \"ui.components.media-browser.media-player-browser\"\n                  )\n                : this._currentItem.title}\n            </div>\n            <ha-media-manage-button\n              .hass=${this.hass}\n              .currentItem=${this._currentItem}\n              @media-refresh=${this._refreshMedia}\n            ></ha-media-manage-button>\n          </app-toolbar>\n        </app-header>\n        <ha-media-player-browse\n          .hass=${this.hass}\n          .entityId=${this._entityId}\n          .navigateIds=${this._navigateIds}\n          @media-picked=${this._mediaPicked}\n          @media-browsed=${this._mediaBrowsed}\n        ></ha-media-player-browse>\n      </ha-app-layout>\n      <ha-bar-media-player\n        .hass=${this.hass}\n        .entityId=${this._entityId}\n        .narrow=${this.narrow}\n        @player-picked=${this._playerPicked}\n      ></ha-bar-media-player>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n\n    if (!changedProps.has(\"route\")) {\n      return;\n    }\n\n    if (this.route.path === \"\") {\n      navigate(`/media-browser/${this._entityId}`, { replace: true });\n      return;\n    }\n\n    const [routePlayer, ...navigateIdsEncoded] = this.route.path\n      .substring(1)\n      .split(\"/\");\n\n    if (routePlayer !== this._entityId) {\n      // Detect if picked player doesn't exist (anymore)\n      // Can happen if URL bookmarked or stored in local storage\n      if (\n        routePlayer !== BROWSER_PLAYER &&\n        this.hass.states[routePlayer] === undefined\n      ) {\n        navigate(`/media-browser/${BROWSER_PLAYER}`, { replace: true });\n        showAlertDialog(this, {\n          text: this.hass.localize(\n            \"ui.panel.media-browser.error.player_not_exist\",\n            {\n              name: routePlayer,\n            }\n          ),\n        });\n        return;\n      }\n      this._entityId = routePlayer;\n    }\n\n    this._navigateIds = [\n      {\n        media_content_type: undefined,\n        media_content_id: undefined,\n      },\n      ...navigateIdsEncoded.map((navigateId) => {\n        const decoded = decodeURIComponent(navigateId);\n        // Don't use split because media_content_id could contain commas\n        const delimiter = decoded.indexOf(\",\");\n        return {\n          media_content_type: decoded.substring(0, delimiter),\n          media_content_id: decoded.substring(delimiter + 1),\n        };\n      }),\n    ];\n    this._currentItem = undefined;\n  }\n\n  private _goBack() {\n    navigate(\n      createMediaPanelUrl(this._entityId, this._navigateIds.slice(0, -1))\n    );\n  }\n\n  private _mediaBrowsed(ev: { detail: HASSDomEvents[\"media-browsed\"] }) {\n    if (ev.detail.ids === this._navigateIds) {\n      this._currentItem = ev.detail.current;\n      return;\n    }\n\n    navigate(createMediaPanelUrl(this._entityId, ev.detail.ids), {\n      replace: ev.detail.replace,\n    });\n  }\n\n  private async _mediaPicked(\n    ev: HASSDomEvent<MediaPickedEvent>\n  ): Promise<void> {\n    const item = ev.detail.item;\n\n    if (this._entityId !== BROWSER_PLAYER) {\n      this._player.showResolvingNewMediaPicked();\n      try {\n        await mediaPlayerPlayMedia(\n          this.hass,\n          this._entityId,\n          item.media_content_id,\n          item.media_content_type\n        );\n      } catch (err) {\n        this._player.hideResolvingNewMediaPicked();\n      }\n      return;\n    }\n\n    // We won't cancel current media being played if we're going to\n    // open a camera.\n    if (isCameraMediaSource(item.media_content_id)) {\n      fireEvent(this, \"hass-more-info\", {\n        entityId: getEntityIdFromCameraMediaSource(item.media_content_id),\n      });\n      return;\n    }\n\n    this._player.showResolvingNewMediaPicked();\n    let resolvedUrl: ResolvedMediaSource;\n    try {\n      resolvedUrl = await resolveMediaSource(this.hass, item.media_content_id);\n    } catch (err: any) {\n      showAlertDialog(this, {\n        title: this.hass.localize(\n          \"ui.components.media-browser.media_browsing_error\"\n        ),\n        text: err.message,\n      });\n      this._player.hideResolvingNewMediaPicked();\n      return;\n    }\n\n    if (resolvedUrl.mime_type.startsWith(\"audio/\")) {\n      this._player.playItem(item, resolvedUrl);\n      return;\n    }\n\n    showWebBrowserPlayMediaDialog(this, {\n      sourceUrl: resolvedUrl.url,\n      sourceType: resolvedUrl.mime_type,\n      title: item.title,\n      can_play: item.can_play,\n    });\n    this._player.hideResolvingNewMediaPicked();\n  }\n\n  private _playerPicked(ev) {\n    const entityId: string = ev.detail.entityId;\n    if (entityId === this._entityId) {\n      return;\n    }\n    navigate(createMediaPanelUrl(entityId, this._navigateIds));\n  }\n\n  private _refreshMedia() {\n    this._browser.refresh();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        app-toolbar {\n          --mdc-theme-primary: var(--app-header-text-color);\n        }\n\n        ha-media-player-browse {\n          height: calc(100vh - (100px + var(--header-height)));\n          direction: ltr;\n        }\n\n        :host([narrow]) ha-media-player-browse {\n          height: calc(100vh - (80px + var(--header-height)));\n        }\n\n        ha-bar-media-player {\n          position: absolute;\n          bottom: 0;\n          left: 0;\n          right: 0;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-panel-media-browser\": PanelMediaBrowser;\n  }\n}\n"],"names":[],"sourceRoot":""}