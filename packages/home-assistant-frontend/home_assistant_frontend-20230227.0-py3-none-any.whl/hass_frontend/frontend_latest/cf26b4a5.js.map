{"version":3,"file":"cf26b4a5.js","mappings":";;AA0CA;;AAEA;AACA;;;AA0QA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAGA;ACpSA;;AAEA;;;AA0RA;AACA;;;;AAIA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;;;AAIA;;ACxRA;;;AAIA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;;;AAhBA;;;;;;;;;AAwDA;ACxFA;AACA;AACA;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACcA;AC2DA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAGA;;;AAIA;;AAEA;AAEA;AACA;AACA;;AAEA;;;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;AAGA;AAEA;AACA;;;AAIA;;;AAKA;;;AAIA;;;AAGA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAIA;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6HA","sources":["webpack://home-assistant-frontend/./src/components/device/ha-device-picker.ts","webpack://home-assistant-frontend/./src/components/ha-area-picker.ts","webpack://home-assistant-frontend/./src/components/ha-blueprint-picker.ts","webpack://home-assistant-frontend/./src/components/ha-markdown.ts","webpack://home-assistant-frontend/./src/layouts/ha-app-layout.js","webpack://home-assistant-frontend/./src/layouts/hass-tabs-subpage-data-table.ts"],"sourcesContent":["import \"@material/mwc-list/mwc-list-item\";\nimport { HassEntity, UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nexport type HaDevicePickerEntityFilterFunc = (entity: HassEntity) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"ha-device-picker\")\nexport class HaDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  /**\n   * Show only devices with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no devices with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only devices with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  /**\n   * List of devices to be excluded.\n   * @type {Array}\n   * @attr exclude-devices\n   */\n  @property({ type: Array, attribute: \"exclude-devices\" })\n  public excludeDevices?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property() public entityFilter?: HaDevicePickerEntityFilterFunc;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"],\n      entityFilter: this[\"entityFilter\"],\n      excludeDevices: this[\"excludeDevices\"]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      if (\n        includeDomains ||\n        excludeDomains ||\n        includeDeviceClasses ||\n        entityFilter\n      ) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      let inputDevices = devices.filter(\n        (device) => device.id === this.value || !device.disabled_by\n      );\n\n      if (includeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDevices) {\n        inputDevices = inputDevices.filter(\n          (device) => !excludeDevices!.includes(device.id)\n        );\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n      }\n\n      if (entityFilter) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return devEntities.some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return entityFilter(stateObj);\n          });\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices.filter(\n          (device) =>\n            // We always want to include the device of the current value\n            device.id === this.value || deviceFilter!(device)\n        );\n      }\n\n      const outputDevices = inputDevices.map((device) => ({\n        id: device.id,\n        name: computeDeviceName(\n          device,\n          this.hass,\n          deviceEntityLookup[device.id]\n        ),\n        area:\n          device.area_id && areaLookup[device.area_id]\n            ? areaLookup[device.area_id].name\n            : this.hass.localize(\"ui.components.device-picker.no_area\"),\n      }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\", this.hass.locale.language)\n      );\n    }\n  );\n\n  public async open() {\n    await this.updateComplete;\n    await this.comboBox?.open();\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    await this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices;\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (this._init && changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter,\n        this.entityFilter,\n        this.excludeDevices\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-device-picker\": HaDevicePicker;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport {\n  AreaRegistryEntry,\n  createAreaRegistryEntry,\n} from \"../data/area_registry\";\nimport {\n  DeviceEntityDisplayLookup,\n  DeviceRegistryEntry,\n  getDeviceEntityDisplayLookup,\n} from \"../data/device_registry\";\nimport { EntityRegistryDisplayEntry } from \"../data/entity_registry\";\nimport {\n  showAlertDialog,\n  showPromptDialog,\n} from \"../dialogs/generic/show-dialog-box\";\nimport { PolymerChangedEvent } from \"../polymer-types\";\nimport { HomeAssistant } from \"../types\";\nimport type { HaDevicePickerDeviceFilterFunc } from \"./device/ha-device-picker\";\nimport \"./ha-combo-box\";\nimport type { HaComboBox } from \"./ha-combo-box\";\nimport \"./ha-icon-button\";\nimport \"./ha-svg-icon\";\n\nconst rowRenderer: ComboBoxLitRenderer<AreaRegistryEntry> = (\n  item\n) => html`<mwc-list-item\n  class=${classMap({ \"add-new\": item.area_id === \"add_new\" })}\n>\n  ${item.name}\n</mwc-list-item>`;\n\n@customElement(\"ha-area-picker\")\nexport class HaAreaPicker extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public placeholder?: string;\n\n  @property({ type: Boolean, attribute: \"no-add\" })\n  public noAdd?: boolean;\n\n  /**\n   * Show only areas with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no areas with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only areas with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  /**\n   * List of areas to be excluded.\n   * @type {Array}\n   * @attr exclude-areas\n   */\n  @property({ type: Array, attribute: \"exclude-areas\" })\n  public excludeAreas?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property() public entityFilter?: (entity: HassEntity) => boolean;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _suggestion?: string;\n\n  private _init = false;\n\n  public async open() {\n    await this.updateComplete;\n    await this.comboBox?.open();\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    await this.comboBox?.focus();\n  }\n\n  private _getAreas = memoizeOne(\n    (\n      areas: AreaRegistryEntry[],\n      devices: DeviceRegistryEntry[],\n      entities: EntityRegistryDisplayEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"],\n      entityFilter: this[\"entityFilter\"],\n      noAdd: this[\"noAdd\"],\n      excludeAreas: this[\"excludeAreas\"]\n    ): AreaRegistryEntry[] => {\n      if (!areas.length) {\n        return [\n          {\n            area_id: \"no_areas\",\n            name: this.hass.localize(\"ui.components.area-picker.no_areas\"),\n            picture: null,\n            aliases: [],\n          },\n        ];\n      }\n\n      let deviceEntityLookup: DeviceEntityDisplayLookup = {};\n      let inputDevices: DeviceRegistryEntry[] | undefined;\n      let inputEntities: EntityRegistryDisplayEntry[] | undefined;\n\n      if (\n        includeDomains ||\n        excludeDomains ||\n        includeDeviceClasses ||\n        deviceFilter ||\n        entityFilter\n      ) {\n        deviceEntityLookup = getDeviceEntityDisplayLookup(entities);\n        inputDevices = devices;\n        inputEntities = entities.filter((entity) => entity.area_id);\n\n        if (includeDomains) {\n          inputDevices = inputDevices!.filter((device) => {\n            const devEntities = deviceEntityLookup[device.id];\n            if (!devEntities || !devEntities.length) {\n              return false;\n            }\n            return deviceEntityLookup[device.id].some((entity) =>\n              includeDomains.includes(computeDomain(entity.entity_id))\n            );\n          });\n          inputEntities = inputEntities!.filter((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        }\n\n        if (excludeDomains) {\n          inputDevices = inputDevices!.filter((device) => {\n            const devEntities = deviceEntityLookup[device.id];\n            if (!devEntities || !devEntities.length) {\n              return true;\n            }\n            return entities.every(\n              (entity) =>\n                !excludeDomains.includes(computeDomain(entity.entity_id))\n            );\n          });\n          inputEntities = inputEntities!.filter(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        }\n\n        if (includeDeviceClasses) {\n          inputDevices = inputDevices!.filter((device) => {\n            const devEntities = deviceEntityLookup[device.id];\n            if (!devEntities || !devEntities.length) {\n              return false;\n            }\n            return deviceEntityLookup[device.id].some((entity) => {\n              const stateObj = this.hass.states[entity.entity_id];\n              if (!stateObj) {\n                return false;\n              }\n              return (\n                stateObj.attributes.device_class &&\n                includeDeviceClasses.includes(stateObj.attributes.device_class)\n              );\n            });\n          });\n          inputEntities = inputEntities!.filter((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        }\n\n        if (deviceFilter) {\n          inputDevices = inputDevices!.filter((device) =>\n            deviceFilter!(device)\n          );\n        }\n\n        if (entityFilter) {\n          inputDevices = inputDevices!.filter((device) => {\n            const devEntities = deviceEntityLookup[device.id];\n            if (!devEntities || !devEntities.length) {\n              return false;\n            }\n            return deviceEntityLookup[device.id].some((entity) => {\n              const stateObj = this.hass.states[entity.entity_id];\n              if (!stateObj) {\n                return false;\n              }\n              return entityFilter(stateObj);\n            });\n          });\n          inputEntities = inputEntities!.filter((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return entityFilter!(stateObj);\n          });\n        }\n      }\n\n      let outputAreas = areas;\n\n      let areaIds: string[] | undefined;\n\n      if (inputDevices) {\n        areaIds = inputDevices\n          .filter((device) => device.area_id)\n          .map((device) => device.area_id!);\n      }\n\n      if (inputEntities) {\n        areaIds = (areaIds ?? []).concat(\n          inputEntities\n            .filter((entity) => entity.area_id)\n            .map((entity) => entity.area_id!)\n        );\n      }\n\n      if (areaIds) {\n        outputAreas = areas.filter((area) => areaIds!.includes(area.area_id));\n      }\n\n      if (excludeAreas) {\n        outputAreas = outputAreas.filter(\n          (area) => !excludeAreas!.includes(area.area_id)\n        );\n      }\n\n      if (!outputAreas.length) {\n        outputAreas = [\n          {\n            area_id: \"no_areas\",\n            name: this.hass.localize(\"ui.components.area-picker.no_match\"),\n            picture: null,\n            aliases: [],\n          },\n        ];\n      }\n\n      return noAdd\n        ? outputAreas\n        : [\n            ...outputAreas,\n            {\n              area_id: \"add_new\",\n              name: this.hass.localize(\"ui.components.area-picker.add_new\"),\n              picture: null,\n              aliases: [],\n            },\n          ];\n    }\n  );\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.hass) ||\n      (this._init && changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      const areas = this._getAreas(\n        Object.values(this.hass.areas),\n        Object.values(this.hass.devices),\n        Object.values(this.hass.entities),\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter,\n        this.entityFilter,\n        this.noAdd,\n        this.excludeAreas\n      );\n      (this.comboBox as any).items = areas;\n      (this.comboBox as any).filteredItems = areas;\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .helper=${this.helper}\n        item-value-path=\"area_id\"\n        item-id-path=\"area_id\"\n        item-label-path=\"name\"\n        .value=${this.value}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.area-picker.area\")\n          : this.label}\n        .placeholder=${this.placeholder\n          ? this.hass.areas[this.placeholder]?.name\n          : undefined}\n        .renderer=${rowRenderer}\n        @filter-changed=${this._filterChanged}\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._areaChanged}\n      >\n      </ha-combo-box>\n    `;\n  }\n\n  private _filterChanged(ev: CustomEvent): void {\n    const filter = ev.detail.value;\n    if (!filter) {\n      this.comboBox.filteredItems = this.comboBox.items;\n      return;\n    }\n\n    const filteredItems = this.comboBox.items?.filter((item) =>\n      item.name.toLowerCase().includes(filter!.toLowerCase())\n    );\n    if (!this.noAdd && filteredItems?.length === 0) {\n      this._suggestion = filter;\n      this.comboBox.filteredItems = [\n        {\n          area_id: \"add_new_suggestion\",\n          name: this.hass.localize(\n            \"ui.components.area-picker.add_new_sugestion\",\n            { name: this._suggestion }\n          ),\n          picture: null,\n        },\n      ];\n    } else {\n      this.comboBox.filteredItems = filteredItems;\n    }\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _areaChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_areas\") {\n      newValue = \"\";\n    }\n\n    if (![\"add_new_suggestion\", \"add_new\"].includes(newValue)) {\n      if (newValue !== this._value) {\n        this._setValue(newValue);\n      }\n      return;\n    }\n\n    (ev.target as any).value = this._value;\n    showPromptDialog(this, {\n      title: this.hass.localize(\"ui.components.area-picker.add_dialog.title\"),\n      text: this.hass.localize(\"ui.components.area-picker.add_dialog.text\"),\n      confirmText: this.hass.localize(\n        \"ui.components.area-picker.add_dialog.add\"\n      ),\n      inputLabel: this.hass.localize(\n        \"ui.components.area-picker.add_dialog.name\"\n      ),\n      defaultValue:\n        newValue === \"add_new_suggestion\" ? this._suggestion : undefined,\n      confirm: async (name) => {\n        if (!name) {\n          return;\n        }\n        try {\n          const area = await createAreaRegistryEntry(this.hass, {\n            name,\n          });\n          const areas = [...Object.values(this.hass.areas), area];\n          (this.comboBox as any).filteredItems = this._getAreas(\n            areas,\n            Object.values(this.hass.devices)!,\n            Object.values(this.hass.entities)!,\n            this.includeDomains,\n            this.excludeDomains,\n            this.includeDeviceClasses,\n            this.deviceFilter,\n            this.entityFilter,\n            this.noAdd,\n            this.excludeAreas\n          );\n          await this.updateComplete;\n          await this.comboBox.updateComplete;\n          this._setValue(area.area_id);\n        } catch (err: any) {\n          showAlertDialog(this, {\n            title: this.hass.localize(\n              \"ui.components.area-picker.add_dialog.failed_create_area\"\n            ),\n            text: err.message,\n          });\n        }\n      },\n      cancel: () => {\n        this._setValue(undefined);\n        this._suggestion = undefined;\n      },\n    });\n  }\n\n  private _setValue(value?: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-area-picker\": HaAreaPicker;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport { stringCompare } from \"../common/string/compare\";\nimport {\n  Blueprint,\n  BlueprintDomain,\n  Blueprints,\n  fetchBlueprints,\n} from \"../data/blueprint\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-select\";\n\n@customElement(\"ha-blueprint-picker\")\nclass HaBluePrintPicker extends LitElement {\n  public hass?: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value = \"\";\n\n  @property() public domain: BlueprintDomain = \"automation\";\n\n  @property() public blueprints?: Blueprints;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  public open() {\n    const select = this.shadowRoot?.querySelector(\"ha-select\");\n    if (select) {\n      // @ts-expect-error\n      select.menuOpen = true;\n    }\n  }\n\n  private _processedBlueprints = memoizeOne((blueprints?: Blueprints) => {\n    if (!blueprints) {\n      return [];\n    }\n    const result = Object.entries(blueprints)\n      .filter((entry): entry is [string, Blueprint] => !(\"error\" in entry[1]))\n      .map(([path, blueprint]) => ({\n        ...blueprint.metadata,\n        path,\n      }));\n    return result.sort((a, b) =>\n      stringCompare(a.name, b.name, this.hass!.locale.language)\n    );\n  });\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n    return html`\n      <ha-select\n        .label=${this.label ||\n        this.hass.localize(\"ui.components.blueprint-picker.select_blueprint\")}\n        fixedMenuPosition\n        naturalMenuWidth\n        .value=${this.value}\n        .disabled=${this.disabled}\n        @selected=${this._blueprintChanged}\n        @closed=${stopPropagation}\n      >\n        ${this._processedBlueprints(this.blueprints).map(\n          (blueprint) => html`\n            <mwc-list-item .value=${blueprint.path}>\n              ${blueprint.name}\n            </mwc-list-item>\n          `\n        )}\n      </ha-select>\n    `;\n  }\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    if (this.blueprints === undefined) {\n      fetchBlueprints(this.hass!, this.domain).then((blueprints) => {\n        this.blueprints = blueprints;\n      });\n    }\n  }\n\n  private _blueprintChanged(ev) {\n    const newValue = ev.target.value;\n\n    if (newValue !== this.value) {\n      this.value = newValue;\n      setTimeout(() => {\n        fireEvent(this, \"value-changed\", { value: newValue });\n        fireEvent(this, \"change\");\n      }, 0);\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n      }\n      ha-select {\n        width: 100%;\n        min-width: 200px;\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-blueprint-picker\": HaBluePrintPicker;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"./ha-markdown-element\";\n\n// Import components that are allwoed to be defined.\nimport \"./ha-alert\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-markdown\")\nexport class HaMarkdown extends LitElement {\n  @property() public content?;\n\n  @property({ type: Boolean }) public allowSvg = false;\n\n  @property({ type: Boolean }) public breaks = false;\n\n  protected render(): TemplateResult {\n    if (!this.content) {\n      return html``;\n    }\n\n    return html`<ha-markdown-element\n      .content=${this.content}\n      .allowSvg=${this.allowSvg}\n      .breaks=${this.breaks}\n    ></ha-markdown-element>`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n      ha-markdown-element {\n        -ms-user-select: text;\n        -webkit-user-select: text;\n        -moz-user-select: text;\n      }\n      ha-markdown-element > *:first-child {\n        margin-top: 0;\n      }\n      ha-markdown-element > *:last-child {\n        margin-bottom: 0;\n      }\n      a {\n        color: var(--primary-color);\n      }\n      img {\n        max-width: 100%;\n      }\n      code,\n      pre {\n        background-color: var(--markdown-code-background-color, none);\n        border-radius: 3px;\n      }\n      svg {\n        background-color: var(--markdown-svg-background-color, none);\n        color: var(--markdown-svg-color, none);\n      }\n      code {\n        font-size: 85%;\n        padding: 0.2em 0.4em;\n      }\n      pre code {\n        padding: 0;\n      }\n      pre {\n        padding: 16px;\n        overflow: auto;\n        line-height: 1.45;\n        font-family: var(--code-font-family, monospace);\n      }\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6 {\n        line-height: initial;\n      }\n      h2 {\n        font-size: 1.5em;\n        font-weight: bold;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-markdown\": HaMarkdown;\n  }\n}\n","/* eslint-plugin-disable lit */\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\nThis code is copied from app-header-layout.\n'fullbleed' support is removed as Home Assisstant doesn't use it.\ntransform: translate(0) is added.\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\nimport \"@polymer/polymer/polymer-element\";\n\nclass HaAppLayout extends customElements.get(\"app-header-layout\") {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n          position: relative;\n          z-index: 0;\n        }\n\n        #wrapper ::slotted([slot=\"header\"]) {\n          @apply --layout-fixed-top;\n          z-index: 1;\n        }\n\n        #wrapper.initializing ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) {\n          height: 100%;\n        }\n\n        :host([has-scrolling-region]) #wrapper ::slotted([slot=\"header\"]) {\n          position: absolute;\n        }\n\n        :host([has-scrolling-region])\n          #wrapper.initializing\n          ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          @apply --layout-fit;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n\n        :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n          position: relative;\n        }\n\n        #contentContainer {\n          /* Create a stacking context here so that all children appear below the header. */\n          position: relative;\n          z-index: 0;\n          /* Using 'transform' will cause 'position: fixed' elements to behave like\n           'position: absolute' relative to this element. */\n          transform: translate(0);\n          margin-left: env(safe-area-inset-left);\n          margin-right: env(safe-area-inset-right);\n          padding-top: env(safe-area-inset-top);\n          padding-bottom: env(safe-area-inset-bottom);\n        }\n\n        @media print {\n          :host([has-scrolling-region]) #wrapper #contentContainer {\n            overflow-y: visible;\n          }\n        }\n      </style>\n\n      <div id=\"wrapper\" class=\"initializing\">\n        <slot id=\"headerSlot\" name=\"header\"></slot>\n\n        <div id=\"contentContainer\"><slot></slot></div>\n        <slot id=\"fab\" name=\"fab\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"ha-app-layout\", HaAppLayout);\n","import \"@material/mwc-button/mwc-button\";\nimport \"@polymer/paper-tooltip/paper-tooltip\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { computeRTLDirection } from \"../common/util/compute_rtl\";\nimport \"../components/data-table/ha-data-table\";\nimport type {\n  DataTableColumnContainer,\n  DataTableRowData,\n  HaDataTable,\n} from \"../components/data-table/ha-data-table\";\nimport type { HomeAssistant, Route } from \"../types\";\nimport \"./hass-tabs-subpage\";\nimport type { PageNavigation } from \"./hass-tabs-subpage\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"search-changed\": { value: string };\n    \"clear-filter\": undefined;\n  }\n}\n\n@customElement(\"hass-tabs-subpage-data-table\")\nexport class HaTabsSubpageDataTable extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public localizeFunc?: LocalizeFunc;\n\n  @property({ type: Boolean }) public isWide = false;\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property({ type: Boolean }) public supervisor = false;\n\n  @property({ type: Boolean, attribute: \"main-page\" }) public mainPage = false;\n\n  /**\n   * Object with the columns.\n   * @type {Object}\n   */\n  @property({ type: Object }) public columns: DataTableColumnContainer = {};\n\n  /**\n   * Data to show in the table.\n   * @type {Array}\n   */\n  @property({ type: Array }) public data: DataTableRowData[] = [];\n\n  /**\n   * Should rows be selectable.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public selectable = false;\n\n  /**\n   * Should rows be clickable.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public clickable = false;\n\n  /**\n   * Do we need to add padding for a fab.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public hasFab = false;\n\n  /**\n   * Add an extra row at the bottom of the data table\n   * @type {TemplateResult}\n   */\n  @property({ attribute: false }) public appendRow?: TemplateResult;\n\n  /**\n   * Field with a unique id per entry in data.\n   * @type {String}\n   */\n  @property({ type: String }) public id = \"id\";\n\n  /**\n   * String to filter the data in the data table on.\n   * @type {String}\n   */\n  @property({ type: String }) public filter = \"\";\n\n  @property() public searchLabel?: string;\n\n  /**\n   * List of strings that show what the data is currently filtered by.\n   * @type {Array}\n   */\n  @property({ type: Array }) public activeFilters?;\n\n  /**\n   * Text to how how many items are hidden.\n   * @type {String}\n   */\n  @property() public hiddenLabel?: string;\n\n  /**\n   * How many items are hidden because of active filters.\n   * @type {Number}\n   */\n  @property({ type: Number }) public numHidden = 0;\n\n  /**\n   * What path to use when the back button is pressed.\n   * @type {String}\n   * @attr back-path\n   */\n  @property({ type: String, attribute: \"back-path\" }) public backPath?: string;\n\n  /**\n   * Function to call when the back button is pressed.\n   * @type {() => void}\n   */\n  @property() public backCallback?: () => void;\n\n  /**\n   * String to show when there are no records in the data table.\n   * @type {String}\n   */\n  @property({ type: String }) public noDataText?: string;\n\n  @property() public route!: Route;\n\n  /**\n   * Array of tabs to show on the page.\n   * @type {Array}\n   */\n  @property() public tabs: PageNavigation[] = [];\n\n  /**\n   * Force hides the filter menu.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public hideFilterMenu = false;\n\n  @query(\"ha-data-table\", true) private _dataTable!: HaDataTable;\n\n  public clearSelection() {\n    this._dataTable.clearSelection();\n  }\n\n  protected render(): TemplateResult {\n    const hiddenLabel = this.numHidden\n      ? this.hiddenLabel ||\n        this.hass.localize(\n          \"ui.components.data-table.hidden\",\n          \"number\",\n          this.numHidden\n        ) ||\n        this.numHidden\n      : undefined;\n\n    const filterInfo = this.activeFilters\n      ? html`${this.hass.localize(\"ui.components.data-table.filtering_by\")}\n        ${this.activeFilters.join(\", \")}\n        ${hiddenLabel ? `(${hiddenLabel})` : \"\"}`\n      : hiddenLabel;\n\n    const headerToolbar = html`<search-input\n      .hass=${this.hass}\n      .filter=${this.filter}\n      .suffix=${!this.narrow}\n      @value-changed=${this._handleSearchChange}\n      .label=${this.searchLabel ||\n      this.hass.localize(\"ui.components.data-table.search\")}\n    >\n      ${!this.narrow\n        ? html`<div\n            class=\"filters\"\n            slot=\"suffix\"\n            @click=${this._preventDefault}\n          >\n            ${filterInfo\n              ? html`<div class=\"active-filters\">\n                  ${filterInfo}\n                  <mwc-button @click=${this._clearFilter}>\n                    ${this.hass.localize(\"ui.components.data-table.clear\")}\n                  </mwc-button>\n                </div>`\n              : \"\"}\n            <slot name=\"filter-menu\"></slot>\n          </div>`\n        : \"\"}\n    </search-input>`;\n\n    return html`\n      <hass-tabs-subpage\n        .hass=${this.hass}\n        .localizeFunc=${this.localizeFunc}\n        .narrow=${this.narrow}\n        .isWide=${this.isWide}\n        .backPath=${this.backPath}\n        .backCallback=${this.backCallback}\n        .route=${this.route}\n        .tabs=${this.tabs}\n        .mainPage=${this.mainPage}\n        .supervisor=${this.supervisor}\n      >\n        ${!this.hideFilterMenu\n          ? html`\n              <div slot=\"toolbar-icon\">\n                ${this.narrow\n                  ? html`\n                      <div class=\"filter-menu\">\n                        ${this.numHidden || this.activeFilters\n                          ? html`<span class=\"badge\"\n                              >${this.numHidden || \"!\"}</span\n                            >`\n                          : \"\"}\n                        <slot name=\"filter-menu\"></slot>\n                      </div>\n                    `\n                  : \"\"}<slot name=\"toolbar-icon\"></slot>\n              </div>\n            `\n          : \"\"}\n        ${this.narrow\n          ? html`\n              <div slot=\"header\">\n                <slot name=\"header\">\n                  <div class=\"search-toolbar\">${headerToolbar}</div>\n                </slot>\n              </div>\n            `\n          : \"\"}\n        <ha-data-table\n          .hass=${this.hass}\n          .columns=${this.columns}\n          .data=${this.data}\n          .filter=${this.filter}\n          .selectable=${this.selectable}\n          .hasFab=${this.hasFab}\n          .id=${this.id}\n          .noDataText=${this.noDataText}\n          .dir=${computeRTLDirection(this.hass)}\n          .clickable=${this.clickable}\n          .appendRow=${this.appendRow}\n        >\n          ${!this.narrow\n            ? html`\n                <div slot=\"header\">\n                  <slot name=\"header\">\n                    <div class=\"table-header\">${headerToolbar}</div>\n                  </slot>\n                </div>\n              `\n            : html` <div slot=\"header\"></div> `}\n        </ha-data-table>\n        <div slot=\"fab\"><slot name=\"fab\"></slot></div>\n      </hass-tabs-subpage>\n    `;\n  }\n\n  private _preventDefault(ev) {\n    ev.preventDefault();\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    if (this.filter === ev.detail.value) {\n      return;\n    }\n    this.filter = ev.detail.value;\n    fireEvent(this, \"search-changed\", { value: this.filter });\n  }\n\n  private _clearFilter() {\n    fireEvent(this, \"clear-filter\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-data-table {\n        width: 100%;\n        height: 100%;\n        --data-table-border-width: 0;\n      }\n      :host(:not([narrow])) ha-data-table {\n        height: calc(100vh - 1px - var(--header-height));\n        display: block;\n      }\n      :host([narrow]) hass-tabs-subpage {\n        --main-title-margin: 0;\n      }\n      .table-header {\n        display: flex;\n        align-items: center;\n        --mdc-shape-small: 0;\n        height: 56px;\n      }\n      .search-toolbar {\n        display: flex;\n        align-items: center;\n        color: var(--secondary-text-color);\n      }\n      search-input {\n        --mdc-text-field-fill-color: var(--sidebar-background-color);\n        --mdc-text-field-idle-line-color: var(--divider-color);\n        --text-field-overflow: visible;\n        z-index: 5;\n      }\n      .table-header search-input {\n        display: block;\n        position: absolute;\n        top: 0;\n        right: 0;\n        left: 0;\n      }\n      .search-toolbar search-input {\n        display: block;\n        width: 100%;\n        color: var(--secondary-text-color);\n        --mdc-ripple-color: transparant;\n      }\n      .filters {\n        --mdc-text-field-fill-color: var(--input-fill-color);\n        --mdc-text-field-idle-line-color: var(--input-idle-line-color);\n        --mdc-shape-small: 4px;\n        --text-field-overflow: initial;\n        display: flex;\n        justify-content: flex-end;\n        margin-right: 8px;\n        color: var(--primary-text-color);\n      }\n      .active-filters {\n        color: var(--primary-text-color);\n        position: relative;\n        display: flex;\n        align-items: center;\n        padding: 2px 2px 2px 8px;\n        margin-left: 4px;\n        margin-inline-start: 4px;\n        margin-inline-end: initial;\n        font-size: 14px;\n        width: max-content;\n        cursor: initial;\n        direction: var(--direction);\n      }\n      .active-filters ha-svg-icon {\n        color: var(--primary-color);\n      }\n      .active-filters mwc-button {\n        margin-left: 8px;\n        margin-inline-start: 8px;\n        margin-inline-end: initial;\n        direction: var(--direction);\n      }\n      .active-filters::before {\n        background-color: var(--primary-color);\n        opacity: 0.12;\n        border-radius: 4px;\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        content: \"\";\n      }\n      .badge {\n        min-width: 20px;\n        box-sizing: border-box;\n        border-radius: 50%;\n        font-weight: 400;\n        background-color: var(--primary-color);\n        line-height: 20px;\n        text-align: center;\n        padding: 0px 4px;\n        color: var(--text-primary-color);\n        position: absolute;\n        right: 0;\n        top: 4px;\n        font-size: 0.65em;\n      }\n      .filter-menu {\n        position: relative;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hass-tabs-subpage-data-table\": HaTabsSubpageDataTable;\n  }\n}\n"],"names":[],"sourceRoot":""}