{"version":3,"file":"95adb793.js","mappings":";AAsBA;AACA;;AAGA;;;;;;;AAQA;;AAGA;;AAIA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;;;AC+EA;;;AAGA;;AAEA;;;AAKA;AACA;;;;;;;AAOA;AAGA;;;AAIA;AACA;AACA;;;;;AAMA;AACA;;AAEA;AACA;;;;;;AAMA;AAGA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;;;AAIA;AACA;;;;;;AAMA;;;;AAMA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;;;;;AAOA;;;;AAIA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;AAIA;AACA;;AAEA;;AAEA;;;AAIA;AACA;;AAEA;;AAEA;;;;AAKA;AACA;;AAEA;;AAIA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqVA;;;AC3cA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;;;AAKA;;;AAKA;;;AAKA;;;AAMA;AAIA;AACA;;AAGA;AAGA;AACA;AACA;;;;AAIA;AAEA;AACA;;;AAIA;AAGA;AAIA;;AAEA;;AAGA;AACA;AACA;AACA;;;;AAUA;;;AAUA;;;AAKA;AACA;AAIA;;AAGA;;;AAMA;AAGA;AACA;AACA;;;;;AAKA;;;AAGA;;;AAGA;;;AAGA;;;AAIA;;;AAKA;AACA;AAGA;;AAEA;AAEA;;;AAIA;AAGA;AACA;AACA;;AAEA;AAGA;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AA4KA","sources":["webpack://home-assistant-frontend/./src/components/ha-chip.ts","webpack://home-assistant-frontend/./src/components/ha-textarea.ts","webpack://home-assistant-frontend/./src/panels/calendar/dialog-calendar-event-editor.ts","webpack://home-assistant-frontend/./src/panels/calendar/ha-recurrence-rule-editor.ts"],"sourcesContent":["// @ts-ignore\nimport chipStyles from \"@material/chips/dist/mdc.chips.min.css\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  TemplateResult,\n  unsafeCSS,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-chip\")\nexport class HaChip extends LitElement {\n  @property({ type: Boolean }) public hasIcon = false;\n\n  @property({ type: Boolean }) public hasTrailingIcon = false;\n\n  @property({ type: Boolean }) public noText = false;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"mdc-chip ${this.noText ? \"no-text\" : \"\"}\">\n        ${this.hasIcon\n          ? html`<div class=\"mdc-chip__icon mdc-chip__icon--leading\">\n              <slot name=\"icon\"></slot>\n            </div>`\n          : null}\n        <div class=\"mdc-chip__ripple\"></div>\n        <span role=\"gridcell\">\n          <span role=\"button\" tabindex=\"0\" class=\"mdc-chip__primary-action\">\n            <span class=\"mdc-chip__text\"><slot></slot></span>\n          </span>\n        </span>\n        ${this.hasTrailingIcon\n          ? html`<div class=\"mdc-chip__icon mdc-chip__icon--trailing\">\n              <slot name=\"trailing-icon\"></slot>\n            </div>`\n          : null}\n      </div>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ${unsafeCSS(chipStyles)}\n      .mdc-chip {\n        background-color: var(\n          --ha-chip-background-color,\n          rgba(var(--rgb-primary-text-color), 0.15)\n        );\n        color: var(--ha-chip-text-color, var(--primary-text-color));\n      }\n\n      .mdc-chip.no-text {\n        padding: 0 10px;\n      }\n\n      .mdc-chip:hover {\n        color: var(--ha-chip-text-color, var(--primary-text-color));\n      }\n\n      .mdc-chip__icon--leading,\n      .mdc-chip__icon--trailing {\n        --mdc-icon-size: 18px;\n        line-height: 14px;\n        color: var(--ha-chip-icon-color, var(--ha-chip-text-color));\n      }\n      .mdc-chip.mdc-chip--selected .mdc-chip__checkmark,\n      .mdc-chip .mdc-chip__icon--leading:not(.mdc-chip__icon--leading-hidden) {\n        margin-right: -4px;\n        margin-inline-start: -4px;\n        margin-inline-end: 4px;\n        direction: var(--direction);\n      }\n\n      span[role=\"gridcell\"] {\n        line-height: 14px;\n      }\n\n      :host {\n        outline: none;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-chip\": HaChip;\n  }\n}\n","import { TextAreaBase } from \"@material/mwc-textarea/mwc-textarea-base\";\nimport { styles as textfieldStyles } from \"@material/mwc-textfield/mwc-textfield.css\";\nimport { styles as textareaStyles } from \"@material/mwc-textarea/mwc-textarea.css\";\nimport { css, PropertyValues } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-textarea\")\nexport class HaTextArea extends TextAreaBase {\n  @property({ type: Boolean, reflect: true }) autogrow = false;\n\n  firstUpdated() {\n    super.firstUpdated();\n\n    this.setAttribute(\"dir\", document.dir);\n  }\n\n  updated(changedProperties: PropertyValues) {\n    super.updated(changedProperties);\n    if (this.autogrow && changedProperties.has(\"value\")) {\n      this.mdcRoot.dataset.value = this.value + '=\\u200B\"'; // add a zero-width space to correctly wrap\n    }\n  }\n\n  static override styles = [\n    textfieldStyles,\n    textareaStyles,\n    css`\n      :host([autogrow]) .mdc-text-field {\n        position: relative;\n        min-height: 74px;\n        min-width: 178px;\n        max-height: 200px;\n      }\n      :host([autogrow]) .mdc-text-field:after {\n        content: attr(data-value);\n        margin-top: 23px;\n        margin-bottom: 9px;\n        line-height: 1.5rem;\n        min-height: 42px;\n        padding: 0px 32px 0 16px;\n        letter-spacing: var(\n          --mdc-typography-subtitle1-letter-spacing,\n          0.009375em\n        );\n        visibility: hidden;\n        white-space: pre-wrap;\n      }\n      :host([autogrow]) .mdc-text-field__input {\n        position: absolute;\n        height: calc(100% - 32px);\n      }\n      :host([autogrow]) .mdc-text-field.mdc-text-field--no-label:after {\n        margin-top: 16px;\n        margin-bottom: 16px;\n      }\n      :host([dir=\"rtl\"]) .mdc-floating-label {\n        right: 16px;\n        left: initial;\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-textarea\": HaTextArea;\n  }\n}\n","import \"@material/mwc-button\";\nimport { mdiClose } from \"@mdi/js\";\nimport {\n  addDays,\n  addHours,\n  addMilliseconds,\n  differenceInMilliseconds,\n  startOfHour,\n} from \"date-fns/esm\";\nimport { formatInTimeZone, toDate } from \"date-fns-tz\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { supportsFeature } from \"../../common/entity/supports-feature\";\nimport { isDate } from \"../../common/string/is_date\";\nimport \"../../components/entity/ha-entity-picker\";\nimport \"../../components/ha-date-input\";\nimport \"../../components/ha-textarea\";\nimport \"../../components/ha-time-input\";\nimport {\n  CalendarEntityFeature,\n  CalendarEventMutableParams,\n  createCalendarEvent,\n  deleteCalendarEvent,\n  updateCalendarEvent,\n  RecurrenceRange,\n} from \"../../data/calendar\";\nimport { haStyleDialog } from \"../../resources/styles\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../lovelace/components/hui-generic-entity-row\";\nimport \"./ha-recurrence-rule-editor\";\nimport { showConfirmEventDialog } from \"./show-confirm-event-dialog-box\";\nimport { CalendarEventEditDialogParams } from \"./show-dialog-calendar-event-editor\";\n\nconst CALENDAR_DOMAINS = [\"calendar\"];\n\n@customElement(\"dialog-calendar-event-editor\")\nclass DialogCalendarEventEditor extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _error?: string;\n\n  @state() private _info?: string;\n\n  @state() private _params?: CalendarEventEditDialogParams;\n\n  @state() private _calendarId?: string;\n\n  @state() private _summary = \"\";\n\n  @state() private _description? = \"\";\n\n  @state() private _rrule?: string;\n\n  @state() private _allDay = false;\n\n  @state() private _dtstart?: Date; // In sync with _data.dtstart\n\n  @state() private _dtend?: Date; // Inclusive for display, in sync with _data.dtend (exclusive)\n\n  @state() private _submitting = false;\n\n  // Dates are manipulated and displayed in the browser timezone\n  // which may be different from the Home Assistant timezone. When\n  // events are persisted, they are relative to the Home Assistant\n  // timezone, but floating without a timezone.\n  private _timeZone?: string;\n\n  public showDialog(params: CalendarEventEditDialogParams): void {\n    this._error = undefined;\n    this._info = undefined;\n    this._params = params;\n    this._calendarId =\n      params.calendarId ||\n      Object.values(this.hass.states).find(\n        (stateObj) =>\n          computeStateDomain(stateObj) === \"calendar\" &&\n          supportsFeature(stateObj, CalendarEntityFeature.CREATE_EVENT)\n      )?.entity_id;\n    this._timeZone =\n      Intl.DateTimeFormat().resolvedOptions().timeZone ||\n      this.hass.config.time_zone;\n    if (params.entry) {\n      const entry = params.entry!;\n      this._allDay = isDate(entry.dtstart);\n      this._summary = entry.summary;\n      this._description = entry.description;\n      this._rrule = entry.rrule;\n      if (this._allDay) {\n        this._dtstart = new Date(entry.dtstart + \"T00:00:00\");\n        // Calendar event end dates are exclusive, but not shown that way in the UI. The\n        // reverse happens when persisting the event.\n        this._dtend = addDays(new Date(entry.dtend + \"T00:00:00\"), -1);\n      } else {\n        this._dtstart = new Date(entry.dtstart);\n        this._dtend = new Date(entry.dtend);\n      }\n    } else {\n      this._allDay = false;\n      // If we have been provided a selected date (e.g. based on the currently displayed\n      // day in a calendar view), use that as the starting value.\n      this._dtstart = startOfHour(\n        params.selectedDate ? params.selectedDate : new Date()\n      );\n      this._dtend = addHours(this._dtstart, 1);\n    }\n  }\n\n  public closeDialog(): void {\n    if (!this._params) {\n      return;\n    }\n    this._calendarId = undefined;\n    this._params = undefined;\n    this._dtstart = undefined;\n    this._dtend = undefined;\n    this._summary = \"\";\n    this._description = \"\";\n    this._rrule = undefined;\n    fireEvent(this, \"dialog-closed\", { dialog: this.localName });\n  }\n\n  protected render(): TemplateResult {\n    if (!this._params) {\n      return html``;\n    }\n    const isCreate = this._params.entry === undefined;\n\n    const { startDate, startTime, endDate, endTime } = this._getLocaleStrings(\n      this._dtstart,\n      this._dtend\n    );\n\n    return html`\n      <ha-dialog\n        open\n        @closed=${this.closeDialog}\n        scrimClickAction\n        escapeKeyAction\n        .heading=${html`\n          <div class=\"header_title\">\n            ${isCreate\n              ? this.hass.localize(\"ui.components.calendar.event.add\")\n              : this._summary}\n          </div>\n          <ha-icon-button\n            .label=${this.hass.localize(\"ui.dialogs.generic.close\")}\n            .path=${mdiClose}\n            dialogAction=\"close\"\n            class=\"header_button\"\n          ></ha-icon-button>\n        `}\n      >\n        <div class=\"content\">\n          ${this._error\n            ? html`<ha-alert alert-type=\"error\">${this._error}</ha-alert>`\n            : \"\"}\n          ${this._info\n            ? html`<ha-alert\n                alert-type=\"info\"\n                dismissable\n                @alert-dismissed-clicked=${this._clearInfo}\n                >${this._info}</ha-alert\n              >`\n            : \"\"}\n\n          <ha-textfield\n            class=\"summary\"\n            name=\"summary\"\n            .label=${this.hass.localize(\"ui.components.calendar.event.summary\")}\n            .value=${this._summary}\n            required\n            @change=${this._handleSummaryChanged}\n            error-message=${this.hass.localize(\"ui.common.error_required\")}\n            dialogInitialFocus\n          ></ha-textfield>\n          <ha-textarea\n            class=\"description\"\n            name=\"description\"\n            .label=${this.hass.localize(\n              \"ui.components.calendar.event.description\"\n            )}\n            .value=${this._description}\n            @change=${this._handleDescriptionChanged}\n            autogrow\n          ></ha-textarea>\n          <ha-entity-picker\n            name=\"calendar\"\n            .hass=${this.hass}\n            .label=${this.hass.localize(\"ui.components.calendar.label\")}\n            .value=${this._calendarId!}\n            .includeDomains=${CALENDAR_DOMAINS}\n            .entityFilter=${this._isEditableCalendar}\n            required\n            @value-changed=${this._handleCalendarChanged}\n          ></ha-entity-picker>\n          <ha-formfield\n            .label=${this.hass.localize(\"ui.components.calendar.event.all_day\")}\n          >\n            <ha-switch\n              id=\"all_day\"\n              .checked=${this._allDay}\n              @change=${this._allDayToggleChanged}\n            ></ha-switch>\n          </ha-formfield>\n\n          <div>\n            <span class=\"label\"\n              >${this.hass.localize(\n                \"ui.components.calendar.event.start\"\n              )}:</span\n            >\n            <div class=\"flex\">\n              <ha-date-input\n                .value=${startDate}\n                .locale=${this.hass.locale}\n                @value-changed=${this._startDateChanged}\n              ></ha-date-input>\n              ${!this._allDay\n                ? html`<ha-time-input\n                    .value=${startTime}\n                    .locale=${this.hass.locale}\n                    @value-changed=${this._startTimeChanged}\n                  ></ha-time-input>`\n                : \"\"}\n            </div>\n          </div>\n          <div>\n            <span class=\"label\"\n              >${this.hass.localize(\"ui.components.calendar.event.end\")}:</span\n            >\n            <div class=\"flex\">\n              <ha-date-input\n                .value=${endDate}\n                .min=${startDate}\n                .locale=${this.hass.locale}\n                @value-changed=${this._endDateChanged}\n              ></ha-date-input>\n              ${!this._allDay\n                ? html`<ha-time-input\n                    .value=${endTime}\n                    .locale=${this.hass.locale}\n                    @value-changed=${this._endTimeChanged}\n                  ></ha-time-input>`\n                : \"\"}\n            </div>\n          </div>\n          <ha-recurrence-rule-editor\n            .hass=${this.hass}\n            .dtstart=${this._dtstart}\n            .allDay=${this._allDay}\n            .locale=${this.hass.locale}\n            .timezone=${this.hass.config.time_zone}\n            .value=${this._rrule || \"\"}\n            @value-changed=${this._handleRRuleChanged}\n          >\n          </ha-recurrence-rule-editor>\n        </div>\n        ${isCreate\n          ? html`\n              <mwc-button\n                slot=\"primaryAction\"\n                @click=${this._createEvent}\n                .disabled=${this._submitting}\n              >\n                ${this.hass.localize(\"ui.components.calendar.event.add\")}\n              </mwc-button>\n            `\n          : html`\n              <mwc-button\n                slot=\"primaryAction\"\n                @click=${this._saveEvent}\n                .disabled=${this._submitting}\n              >\n                ${this.hass.localize(\"ui.components.calendar.event.save\")}\n              </mwc-button>\n              ${this._params.canDelete\n                ? html`\n                    <mwc-button\n                      slot=\"secondaryAction\"\n                      class=\"warning\"\n                      @click=${this._deleteEvent}\n                      .disabled=${this._submitting}\n                    >\n                      ${this.hass.localize(\n                        \"ui.components.calendar.event.delete\"\n                      )}\n                    </mwc-button>\n                  `\n                : \"\"}\n            `}\n      </ha-dialog>\n    `;\n  }\n\n  private _isEditableCalendar = (entityStateObj: HassEntity) =>\n    supportsFeature(entityStateObj, CalendarEntityFeature.CREATE_EVENT);\n\n  private _getLocaleStrings = memoizeOne(\n    (startDate?: Date, endDate?: Date) => ({\n      startDate: this._formatDate(startDate!),\n      startTime: this._formatTime(startDate!),\n      endDate: this._formatDate(endDate!),\n      endTime: this._formatTime(endDate!),\n    })\n  );\n\n  // Formats a date in specified timezone, or defaulting to browser display timezone\n  private _formatDate(date: Date, timeZone: string = this._timeZone!): string {\n    return formatInTimeZone(date, timeZone, \"yyyy-MM-dd\");\n  }\n\n  // Formats a time in specified timezone, or defaulting to browser display timezone\n  private _formatTime(date: Date, timeZone: string = this._timeZone!): string {\n    return formatInTimeZone(date, timeZone, \"HH:mm:ss\"); // 24 hr\n  }\n\n  // Parse a date in the browser timezone\n  private _parseDate(dateStr: string): Date {\n    return toDate(dateStr, { timeZone: this._timeZone! });\n  }\n\n  private _clearInfo() {\n    this._info = undefined;\n  }\n\n  private _handleSummaryChanged(ev) {\n    this._summary = ev.target.value;\n  }\n\n  private _handleDescriptionChanged(ev) {\n    this._description = ev.target.value;\n  }\n\n  private _handleRRuleChanged(ev) {\n    this._rrule = ev.detail.value;\n  }\n\n  private _allDayToggleChanged(ev) {\n    this._allDay = ev.target.checked;\n  }\n\n  private _startDateChanged(ev: CustomEvent) {\n    // Store previous event duration\n    const duration = differenceInMilliseconds(this._dtend!, this._dtstart!);\n\n    this._dtstart = this._parseDate(\n      `${ev.detail.value}T${this._formatTime(this._dtstart!)}`\n    );\n\n    // Prevent that the end time can be before the start time. Try to keep the\n    // duration the same.\n    if (this._dtend! <= this._dtstart!) {\n      this._dtend = addMilliseconds(this._dtstart, duration);\n      this._info = this.hass.localize(\n        \"ui.components.calendar.event.end_auto_adjusted\"\n      );\n    }\n  }\n\n  private _endDateChanged(ev: CustomEvent) {\n    this._dtend = this._parseDate(\n      `${ev.detail.value}T${this._formatTime(this._dtend!)}`\n    );\n  }\n\n  private _startTimeChanged(ev: CustomEvent) {\n    // Store previous event duration\n    const duration = differenceInMilliseconds(this._dtend!, this._dtstart!);\n\n    this._dtstart = this._parseDate(\n      `${this._formatDate(this._dtstart!)}T${ev.detail.value}`\n    );\n\n    // Prevent that the end time can be before the start time. Try to keep the\n    // duration the same.\n    if (this._dtend! <= this._dtstart!) {\n      this._dtend = addMilliseconds(new Date(this._dtstart), duration);\n      this._info = this.hass.localize(\n        \"ui.components.calendar.event.end_auto_adjusted\"\n      );\n    }\n  }\n\n  private _endTimeChanged(ev: CustomEvent) {\n    this._dtend = this._parseDate(\n      `${this._formatDate(this._dtend!)}T${ev.detail.value}`\n    );\n  }\n\n  private _calculateData() {\n    const data: CalendarEventMutableParams = {\n      summary: this._summary,\n      description: this._description,\n      rrule: this._rrule || undefined,\n      dtstart: \"\",\n      dtend: \"\",\n    };\n    if (this._allDay) {\n      data.dtstart = this._formatDate(this._dtstart!);\n      // End date/time is exclusive when persisted\n      data.dtend = this._formatDate(addDays(this._dtend!, 1));\n    } else {\n      data.dtstart = `${this._formatDate(\n        this._dtstart!,\n        this.hass.config.time_zone\n      )}T${this._formatTime(this._dtstart!, this.hass.config.time_zone)}`;\n      data.dtend = `${this._formatDate(\n        this._dtend!,\n        this.hass.config.time_zone\n      )}T${this._formatTime(this._dtend!, this.hass.config.time_zone)}`;\n    }\n    return data;\n  }\n\n  private _handleCalendarChanged(ev: CustomEvent) {\n    this._calendarId = ev.detail.value;\n  }\n\n  private _isValidStartEnd(): boolean {\n    if (this._allDay) {\n      return this._dtend! >= this._dtstart!;\n    }\n    return this._dtend! > this._dtstart!;\n  }\n\n  private async _createEvent() {\n    if (!this._summary || !this._calendarId) {\n      this._error = this.hass.localize(\n        \"ui.components.calendar.event.not_all_required_fields\"\n      );\n      return;\n    }\n\n    if (!this._isValidStartEnd()) {\n      this._error = this.hass.localize(\n        \"ui.components.calendar.event.invalid_duration\"\n      );\n      return;\n    }\n\n    this._submitting = true;\n    try {\n      await createCalendarEvent(\n        this.hass!,\n        this._calendarId!,\n        this._calculateData()\n      );\n    } catch (err: any) {\n      this._error = err ? err.message : \"Unknown error\";\n      return;\n    } finally {\n      this._submitting = false;\n    }\n    await this._params!.updated();\n    this.closeDialog();\n  }\n\n  private async _saveEvent() {\n    if (!this._summary || !this._calendarId) {\n      this._error = this.hass.localize(\n        \"ui.components.calendar.event.not_all_required_fields\"\n      );\n      return;\n    }\n\n    if (!this._isValidStartEnd()) {\n      this._error = this.hass.localize(\n        \"ui.components.calendar.event.invalid_duration\"\n      );\n      return;\n    }\n\n    this._submitting = true;\n    const entry = this._params!.entry!;\n    let range: RecurrenceRange | undefined = RecurrenceRange.THISEVENT;\n    if (entry.recurrence_id) {\n      range = await showConfirmEventDialog(this, {\n        title: this.hass.localize(\n          \"ui.components.calendar.event.confirm_update.update\"\n        ),\n        text: this.hass.localize(\n          \"ui.components.calendar.event.confirm_update.recurring_prompt\"\n        ),\n        confirmText: this.hass.localize(\n          \"ui.components.calendar.event.confirm_update.update_this\"\n        ),\n        confirmFutureText: this.hass.localize(\n          \"ui.components.calendar.event.confirm_update.update_future\"\n        ),\n      });\n    }\n    if (range === undefined) {\n      // Cancel\n      this._submitting = false;\n      return;\n    }\n    try {\n      await updateCalendarEvent(\n        this.hass!,\n        this._calendarId!,\n        entry.uid!,\n        this._calculateData(),\n        entry.recurrence_id || \"\",\n        range!\n      );\n    } catch (err: any) {\n      this._error = err ? err.message : \"Unknown error\";\n      return;\n    } finally {\n      this._submitting = false;\n    }\n    await this._params!.updated();\n    this.closeDialog();\n  }\n\n  private async _deleteEvent() {\n    this._submitting = true;\n    const entry = this._params!.entry!;\n    const range = await showConfirmEventDialog(this, {\n      title: this.hass.localize(\n        \"ui.components.calendar.event.confirm_delete.delete\"\n      ),\n      text: entry.recurrence_id\n        ? this.hass.localize(\n            \"ui.components.calendar.event.confirm_delete.recurring_prompt\"\n          )\n        : this.hass.localize(\n            \"ui.components.calendar.event.confirm_delete.prompt\"\n          ),\n      confirmText: entry.recurrence_id\n        ? this.hass.localize(\n            \"ui.components.calendar.event.confirm_delete.delete_this\"\n          )\n        : this.hass.localize(\n            \"ui.components.calendar.event.confirm_delete.delete\"\n          ),\n      confirmFutureText: entry.recurrence_id\n        ? this.hass.localize(\n            \"ui.components.calendar.event.confirm_delete.delete_future\"\n          )\n        : undefined,\n    });\n    if (range === undefined) {\n      // Cancel\n      this._submitting = false;\n      return;\n    }\n    try {\n      await deleteCalendarEvent(\n        this.hass!,\n        this._calendarId!,\n        entry.uid!,\n        entry.recurrence_id || \"\",\n        range!\n      );\n    } catch (err: any) {\n      this._error = err ? err.message : \"Unknown error\";\n      return;\n    } finally {\n      this._submitting = false;\n    }\n    await this._params!.updated();\n    this.closeDialog();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyleDialog,\n      css`\n        state-info {\n          line-height: 40px;\n        }\n        ha-alert {\n          display: block;\n          margin-bottom: 16px;\n        }\n        ha-textfield,\n        ha-textarea {\n          display: block;\n        }\n        ha-textarea {\n          margin-bottom: 16px;\n        }\n        ha-formfield {\n          display: block;\n          padding: 16px 0;\n        }\n        ha-date-input {\n          flex-grow: 1;\n        }\n        ha-time-input {\n          margin-left: 16px;\n        }\n        ha-recurrence-rule-editor {\n          display: block;\n          margin-top: 16px;\n        }\n        .flex {\n          display: flex;\n          justify-content: space-between;\n        }\n        .label {\n          font-size: 12px;\n          font-weight: 500;\n          color: var(--input-label-ink-color);\n        }\n        .date-range-details-content {\n          display: inline-block;\n        }\n        ha-rrule {\n          display: block;\n        }\n        ha-svg-icon {\n          width: 40px;\n          margin-right: 8px;\n          margin-inline-end: 16px;\n          margin-inline-start: initial;\n          direction: var(--direction);\n          vertical-align: top;\n        }\n        ha-rrule {\n          display: inline-block;\n        }\n        .key {\n          display: inline-block;\n          vertical-align: top;\n        }\n        .value {\n          display: inline-block;\n          vertical-align: top;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"dialog-calendar-event-editor\": DialogCalendarEventEditor;\n  }\n}\n","import type { SelectedDetail } from \"@material/mwc-list\";\nimport { formatInTimeZone, toDate } from \"date-fns-tz\";\nimport { css, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport type { Options, WeekdayStr } from \"rrule\";\nimport { ByWeekday, RRule, Weekday } from \"rrule\";\nimport { firstWeekdayIndex } from \"../../common/datetime/first_weekday\";\nimport { stopPropagation } from \"../../common/dom/stop_propagation\";\nimport { LocalizeKeys } from \"../../common/translations/localize\";\nimport \"../../components/ha-chip\";\nimport \"../../components/ha-list-item\";\nimport \"../../components/ha-select\";\nimport type { HaSelect } from \"../../components/ha-select\";\nimport \"../../components/ha-textfield\";\nimport { HomeAssistant } from \"../../types\";\nimport {\n  convertFrequency,\n  convertRepeatFrequency,\n  DEFAULT_COUNT,\n  getWeekday,\n  getWeekdays,\n  getMonthlyRepeatItems,\n  RepeatEnd,\n  RepeatFrequency,\n  ruleByWeekDay,\n  untilValue,\n  MonthlyRepeatItem,\n  getMonthlyRepeatWeekdayFromRule,\n  getMonthdayRepeatFromRule,\n} from \"./recurrence\";\nimport \"../../components/ha-date-input\";\n\n@customElement(\"ha-recurrence-rule-editor\")\nexport class RecurrenceRuleEditor extends LitElement {\n  @property() public hass!: HomeAssistant;\n\n  @property() public disabled = false;\n\n  @property() public value = \"\";\n\n  @property() public dtstart?: Date;\n\n  @property() public allDay?: boolean;\n\n  @property({ attribute: false }) public locale!: HomeAssistant[\"locale\"];\n\n  @property() public timezone?: string;\n\n  @state() private _computedRRule = \"\";\n\n  @state() private _freq?: RepeatFrequency = \"none\";\n\n  @state() private _interval = 1;\n\n  @state() private _weekday: Set<WeekdayStr> = new Set<WeekdayStr>();\n\n  @state() private _monthlyRepeat?: string;\n\n  @state() private _monthlyRepeatWeekday?: Weekday;\n\n  @state() private _monthday?: number;\n\n  @state() private _end: RepeatEnd = \"never\";\n\n  @state() private _count?: number;\n\n  @state() private _untilDay?: Date;\n\n  @query(\"#monthly\") private _monthlyRepeatSelect!: HaSelect;\n\n  private _allWeekdays?: WeekdayStr[];\n\n  private _monthlyRepeatItems: MonthlyRepeatItem[] = [];\n\n  protected willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n\n    if (changedProps.has(\"locale\")) {\n      this._allWeekdays = getWeekdays(firstWeekdayIndex(this.locale)).map(\n        (day: Weekday) => day.toString() as WeekdayStr\n      );\n    }\n\n    if (changedProps.has(\"dtstart\") || changedProps.has(\"_interval\")) {\n      this._monthlyRepeatItems = this.dtstart\n        ? getMonthlyRepeatItems(this.hass, this._interval, this.dtstart)\n        : [];\n      this._computeWeekday();\n      const selectElement = this._monthlyRepeatSelect;\n      if (selectElement) {\n        const oldSelected = selectElement.index;\n        selectElement.select(-1);\n        this.updateComplete.then(() => {\n          selectElement.select(changedProps.has(\"dtstart\") ? 0 : oldSelected);\n        });\n      }\n    }\n\n    if (\n      !changedProps.has(\"value\") &&\n      (changedProps.has(\"dtstart\") ||\n        changedProps.has(\"timezone\") ||\n        changedProps.has(\"_freq\") ||\n        changedProps.has(\"_interval\") ||\n        changedProps.has(\"_weekday\") ||\n        changedProps.has(\"_monthlyRepeatWeekday\") ||\n        changedProps.has(\"_monthday\") ||\n        changedProps.has(\"_end\") ||\n        changedProps.has(\"_count\") ||\n        changedProps.has(\"_untilDay\"))\n    ) {\n      this._updateRule();\n      return;\n    }\n\n    if (this._computedRRule === this.value) {\n      return;\n    }\n\n    this._interval = 1;\n    this._weekday.clear();\n    this._monthlyRepeat = undefined;\n    this._monthday = undefined;\n    this._monthlyRepeatWeekday = undefined;\n    this._end = \"never\";\n    this._count = undefined;\n    this._untilDay = undefined;\n\n    this._computedRRule = this.value;\n    if (this.value === \"\") {\n      this._freq = \"none\";\n      return;\n    }\n    let rrule: Partial<Options> | undefined;\n    try {\n      rrule = RRule.parseString(this.value);\n    } catch (ex) {\n      // unsupported rrule string\n      this._freq = undefined;\n      return;\n    }\n    this._freq = convertFrequency(rrule!.freq!);\n    if (rrule.interval) {\n      this._interval = rrule.interval;\n    }\n    this._monthlyRepeatWeekday = getMonthlyRepeatWeekdayFromRule(rrule);\n    if (this._monthlyRepeatWeekday) {\n      this._monthlyRepeat = `BYDAY=${this._monthlyRepeatWeekday.toString()}`;\n    }\n    this._monthday = getMonthdayRepeatFromRule(rrule);\n    if (this._monthday) {\n      this._monthlyRepeat = `BYMONTHDAY=${this._monthday}`;\n    }\n    if (\n      this._freq === \"weekly\" &&\n      rrule.byweekday &&\n      Array.isArray(rrule.byweekday)\n    ) {\n      this._weekday = new Set<WeekdayStr>(\n        rrule.byweekday.map(\n          (value: ByWeekday) => value.toString() as WeekdayStr\n        )\n      );\n    }\n    if (rrule.until) {\n      this._end = \"on\";\n      this._untilDay = toDate(rrule.until, { timeZone: this.timezone });\n    } else if (rrule.count) {\n      this._end = \"after\";\n      this._count = rrule.count;\n    }\n  }\n\n  renderRepeat() {\n    return html`\n      <ha-select\n        id=\"freq\"\n        label=${this.hass.localize(\"ui.components.calendar.event.repeat.label\")}\n        @selected=${this._onRepeatSelected}\n        @closed=${stopPropagation}\n        fixedMenuPosition\n        naturalMenuWidth\n        .value=${this._freq}\n      >\n        <ha-list-item value=\"none\">\n          ${this.hass.localize(\"ui.components.calendar.event.repeat.freq.none\")}\n        </ha-list-item>\n        <ha-list-item value=\"yearly\">\n          ${this.hass.localize(\n            \"ui.components.calendar.event.repeat.freq.yearly\"\n          )}\n        </ha-list-item>\n        <ha-list-item value=\"monthly\">\n          ${this.hass.localize(\n            \"ui.components.calendar.event.repeat.freq.monthly\"\n          )}\n        </ha-list-item>\n        <ha-list-item value=\"weekly\">\n          ${this.hass.localize(\n            \"ui.components.calendar.event.repeat.freq.weekly\"\n          )}\n        </ha-list-item>\n        <ha-list-item value=\"daily\">\n          ${this.hass.localize(\n            \"ui.components.calendar.event.repeat.freq.daily\"\n          )}\n        </ha-list-item>\n      </ha-select>\n    `;\n  }\n\n  renderMonthly() {\n    return html`\n      ${this.renderInterval()}\n      ${this._monthlyRepeatItems.length > 0\n        ? html`<ha-select\n            id=\"monthly\"\n            label=${this.hass.localize(\n              \"ui.components.calendar.event.repeat.monthly.label\"\n            )}\n            @selected=${this._onMonthlyDetailSelected}\n            .value=${this._monthlyRepeat || this._monthlyRepeatItems[0]?.value}\n            @closed=${stopPropagation}\n            fixedMenuPosition\n            naturalMenuWidth\n          >\n            ${this._monthlyRepeatItems!.map(\n              (item) => html`\n                <ha-list-item .value=${item.value} .item=${item}>\n                  ${item.label}\n                </ha-list-item>\n              `\n            )}\n          </ha-select>`\n        : html``}\n    `;\n  }\n\n  renderWeekly() {\n    return html`\n      ${this.renderInterval()}\n      <div class=\"weekdays\">\n        ${this._allWeekdays!.map(\n          (item) => html`\n            <ha-chip\n              .value=${item}\n              class=${classMap({ active: this._weekday.has(item) })}\n              @click=${this._onWeekdayToggle}\n              >${this.hass.localize(\n                `ui.components.calendar.event.repeat.weekly.weekday.${\n                  item.toLowerCase() as Lowercase<WeekdayStr>\n                }`\n              )}</ha-chip\n            >\n          `\n        )}\n      </div>\n    `;\n  }\n\n  renderDaily() {\n    return this.renderInterval();\n  }\n\n  renderInterval() {\n    return html`\n      <ha-textfield\n        id=\"interval\"\n        label=${this.hass.localize(\n          \"ui.components.calendar.event.repeat.interval.label\"\n        )}\n        type=\"number\"\n        min=\"1\"\n        .value=${this._interval}\n        .suffix=${this.hass.localize(\n          `ui.components.calendar.event.repeat.interval.${this\n            ._freq!}` as LocalizeKeys\n        )}\n        @change=${this._onIntervalChange}\n      ></ha-textfield>\n    `;\n  }\n\n  renderEnd() {\n    return html`\n      <ha-select\n        id=\"end\"\n        label=${this.hass.localize(\n          \"ui.components.calendar.event.repeat.end.label\"\n        )}\n        .value=${this._end}\n        @selected=${this._onEndSelected}\n        @closed=${stopPropagation}\n        fixedMenuPosition\n        naturalMenuWidth\n      >\n        <ha-list-item value=\"never\">\n          ${this.hass.localize(\"ui.components.calendar.event.repeat.end.never\")}\n        </ha-list-item>\n        <ha-list-item value=\"after\">\n          ${this.hass.localize(\"ui.components.calendar.event.repeat.end.after\")}\n        </ha-list-item>\n        <ha-list-item value=\"on\">\n          ${this.hass.localize(\"ui.components.calendar.event.repeat.end.on\")}\n        </ha-list-item>\n      </ha-select>\n      ${this._end === \"after\"\n        ? html`\n            <ha-textfield\n              id=\"after\"\n              label=${this.hass.localize(\n                \"ui.components.calendar.event.repeat.end_after.label\"\n              )}\n              type=\"number\"\n              min=\"1\"\n              .value=${this._count!}\n              suffix=${this.hass.localize(\n                \"ui.components.calendar.event.repeat.end_after.ocurrences\"\n              )}\n              @change=${this._onCountChange}\n            ></ha-textfield>\n          `\n        : html``}\n      ${this._end === \"on\"\n        ? html`\n            <ha-date-input\n              id=\"on\"\n              label=${this.hass.localize(\n                \"ui.components.calendar.event.repeat.end_on.label\"\n              )}\n              .locale=${this.locale}\n              .value=${this._formatDate(this._untilDay!)}\n              @value-changed=${this._onUntilChange}\n            ></ha-date-input>\n          `\n        : html``}\n    `;\n  }\n\n  render() {\n    return html`\n      ${this.renderRepeat()}\n      ${this._freq === \"monthly\" ? this.renderMonthly() : html``}\n      ${this._freq === \"weekly\" ? this.renderWeekly() : html``}\n      ${this._freq === \"daily\" ? this.renderDaily() : html``}\n      ${this._freq !== \"none\" ? this.renderEnd() : html``}\n    `;\n  }\n\n  private _onIntervalChange(e: Event) {\n    this._interval = (e.target! as any).value;\n  }\n\n  private _onRepeatSelected(e: CustomEvent<SelectedDetail<number>>) {\n    this._freq = (e.target as HaSelect).value as RepeatFrequency;\n\n    if (this._freq === \"yearly\") {\n      this._interval = 1;\n    }\n    if (this._freq !== \"weekly\") {\n      this._weekday.clear();\n      this._computeWeekday();\n    }\n    e.stopPropagation();\n  }\n\n  private _onMonthlyDetailSelected(e: CustomEvent<SelectedDetail<number>>) {\n    e.stopPropagation();\n    const selectedItem = this._monthlyRepeatItems[e.detail.index];\n    if (!selectedItem) {\n      return;\n    }\n    this._monthlyRepeat = selectedItem.value;\n    this._monthlyRepeatWeekday = selectedItem.byday;\n    this._monthday = selectedItem.bymonthday;\n  }\n\n  private _onWeekdayToggle(e: MouseEvent) {\n    const target = e.currentTarget as any;\n    const value = target.value as WeekdayStr;\n    if (!target.classList.contains(\"active\")) {\n      this._weekday.add(value);\n    } else {\n      this._weekday.delete(value);\n    }\n    this.requestUpdate(\"_weekday\");\n  }\n\n  private _onEndSelected(e: CustomEvent<SelectedDetail<number>>) {\n    const end = (e.target as HaSelect).value as RepeatEnd;\n    if (end === this._end) {\n      return;\n    }\n    this._end = end;\n\n    switch (this._end) {\n      case \"after\":\n        this._count = DEFAULT_COUNT[this._freq!];\n        this._untilDay = undefined;\n        break;\n      case \"on\":\n        this._count = undefined;\n        this._untilDay = untilValue(this._freq!);\n        break;\n      default:\n        this._count = undefined;\n        this._untilDay = undefined;\n    }\n    e.stopPropagation();\n  }\n\n  private _onCountChange(e: Event) {\n    this._count = (e.target! as any).value;\n  }\n\n  private _onUntilChange(e: CustomEvent) {\n    e.stopPropagation();\n    this._untilDay = toDate(e.detail.value + \"T00:00:00\", {\n      timeZone: this.timezone,\n    });\n  }\n\n  // Reset the weekday selected when there is only a single value\n  private _computeWeekday() {\n    if (this.dtstart && this._weekday.size <= 1) {\n      const weekdayNum = getWeekday(this.dtstart);\n      this._weekday.clear();\n      this._weekday.add(new Weekday(weekdayNum).toString() as WeekdayStr);\n    }\n  }\n\n  private _computeRRule() {\n    if (this._freq === undefined || this._freq === \"none\") {\n      return \"\";\n    }\n    let byweekday: Weekday[] | undefined;\n    let bymonthday: number | undefined;\n    if (this._freq === \"monthly\" && this._monthlyRepeatWeekday !== undefined) {\n      byweekday = [this._monthlyRepeatWeekday];\n    } else if (this._freq === \"monthly\" && this._monthday !== undefined) {\n      bymonthday = this._monthday;\n    } else if (this._freq === \"weekly\") {\n      byweekday = ruleByWeekDay(this._weekday);\n    }\n    const options: Partial<Options> = {\n      freq: convertRepeatFrequency(this._freq!)!,\n      interval: this._interval > 1 ? this._interval : undefined,\n      count: this._count,\n      byweekday: byweekday,\n      bymonthday: bymonthday,\n    };\n    let contentline = RRule.optionsToString(options);\n    if (this._untilDay) {\n      // The UNTIL value should be inclusive of the last event instance\n      const until = toDate(\n        this._formatDate(this._untilDay!) +\n          \"T\" +\n          this._formatTime(this.dtstart!),\n        { timeZone: this.timezone }\n      );\n      // rrule.js can't compute some UNTIL variations so we compute that ourself. Must be\n      // in the same format as dtstart.\n      const format = this.allDay ? \"yyyyMMdd\" : \"yyyyMMdd'T'HHmmss\";\n      const newUntilValue = formatInTimeZone(\n        until,\n        this.hass.config.time_zone,\n        format\n      );\n      contentline += `;UNTIL=${newUntilValue}`;\n    }\n    return contentline.slice(6); // Strip \"RRULE:\" prefix\n  }\n\n  // Fire event with an rfc5546 recurrence rule string value\n  private _updateRule() {\n    const rule = this._computeRRule();\n    if (rule === this._computedRRule) {\n      return;\n    }\n    this._computedRRule = rule;\n\n    this.dispatchEvent(\n      new CustomEvent(\"value-changed\", {\n        detail: { value: rule },\n      })\n    );\n  }\n\n  // Formats a date in browser display timezone\n  private _formatDate(date: Date): string {\n    return formatInTimeZone(date, this.timezone!, \"yyyy-MM-dd\");\n  }\n\n  // Formats a time in browser display timezone\n  private _formatTime(date: Date): string {\n    return formatInTimeZone(date, this.timezone!, \"HH:mm:ss\");\n  }\n\n  static styles = css`\n    ha-textfield,\n    ha-select {\n      display: block;\n      margin-bottom: 16px;\n    }\n    .weekdays {\n      display: flex;\n      justify-content: space-between;\n      margin-bottom: 16px;\n    }\n    ha-textfield:last-child,\n    ha-select:last-child,\n    .weekdays:last-child {\n      margin-bottom: 0;\n    }\n\n    .active {\n      --ha-chip-background-color: var(--primary-color);\n      --ha-chip-text-color: var(--text-primary-color);\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-recurrence-rule-editor\": RecurrenceRuleEditor;\n  }\n}\n"],"names":[],"sourceRoot":""}