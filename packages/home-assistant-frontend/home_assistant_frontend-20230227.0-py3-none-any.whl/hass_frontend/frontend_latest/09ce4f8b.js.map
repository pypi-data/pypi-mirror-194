{"version":3,"file":"09ce4f8b.js","mappings":";AA6IA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;;;AAGA;AAGA;AACA;;;;;AAzBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwQA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-map-card.ts"],"sourcesContent":["import { HassEntities } from \"home-assistant-js-websocket\";\nimport { LatLngTuple } from \"leaflet\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { mdiImageFilterCenterFocus } from \"@mdi/js\";\nimport memoizeOne from \"memoize-one\";\nimport { isToday } from \"date-fns\";\nimport { isComponentLoaded } from \"../../../common/config/is_component_loaded\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/ha-icon-button\";\nimport {\n  HistoryStates,\n  subscribeHistoryStatesTimeWindow,\n} from \"../../../data/history\";\nimport { HomeAssistant } from \"../../../types\";\nimport { findEntities } from \"../common/find-entities\";\nimport { processConfigEntities } from \"../common/process-config-entities\";\nimport { EntityConfig } from \"../entity-rows/types\";\nimport { LovelaceCard } from \"../types\";\nimport { MapCardConfig } from \"./types\";\nimport \"../../../components/map/ha-map\";\nimport type {\n  HaMap,\n  HaMapPaths,\n  HaMapPathPoint,\n} from \"../../../components/map/ha-map\";\nimport { getColorByIndex } from \"../../../common/color/colors\";\nimport { formatDateTime } from \"../../../common/datetime/format_date_time\";\nimport {\n  formatTime,\n  formatTimeWeekday,\n} from \"../../../common/datetime/format_time\";\n\nconst DEFAULT_HOURS_TO_SHOW = 0;\n@customElement(\"hui-map-card\")\nclass HuiMapCard extends LitElement implements LovelaceCard {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true })\n  public isPanel = false;\n\n  @state() private _stateHistory?: HistoryStates;\n\n  @state()\n  private _config?: MapCardConfig;\n\n  @query(\"ha-map\")\n  private _map?: HaMap;\n\n  private _configEntities?: string[];\n\n  private _colorDict: Record<string, string> = {};\n\n  private _colorIndex = 0;\n\n  private _error?: string;\n\n  private _subscribed?: Promise<(() => Promise<void>) | void>;\n\n  public setConfig(config: MapCardConfig): void {\n    if (!config) {\n      throw new Error(\"Error in card configuration.\");\n    }\n\n    if (!config.entities?.length && !config.geo_location_sources) {\n      throw new Error(\n        \"Either entities or geo_location_sources must be specified\"\n      );\n    }\n    if (config.entities && !Array.isArray(config.entities)) {\n      throw new Error(\"Entities need to be an array\");\n    }\n    if (\n      config.geo_location_sources &&\n      !Array.isArray(config.geo_location_sources)\n    ) {\n      throw new Error(\"Parameter geo_location_sources needs to be an array\");\n    }\n\n    this._config = config;\n    this._configEntities = (\n      config.entities\n        ? processConfigEntities<EntityConfig>(config.entities)\n        : []\n    ).map((entity) => entity.entity);\n  }\n\n  public getCardSize(): number {\n    if (!this._config?.aspect_ratio) {\n      return 7;\n    }\n\n    const ratio = parseAspectRatio(this._config.aspect_ratio);\n    const ar =\n      ratio && ratio.w > 0 && ratio.h > 0\n        ? `${((100 * ratio.h) / ratio.w).toFixed(2)}`\n        : \"100\";\n\n    return 1 + Math.floor(Number(ar) / 25) || 3;\n  }\n\n  public static async getConfigElement() {\n    await import(\"../editor/config-elements/hui-map-card-editor\");\n    return document.createElement(\"hui-map-card-editor\");\n  }\n\n  public static getStubConfig(\n    hass: HomeAssistant,\n    entities: string[],\n    entitiesFallback: string[]\n  ): MapCardConfig {\n    const includeDomains = [\"device_tracker\"];\n    const maxEntities = 2;\n    const foundEntities = findEntities(\n      hass,\n      maxEntities,\n      entities,\n      entitiesFallback,\n      includeDomains\n    );\n\n    return { type: \"map\", entities: foundEntities };\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config) {\n      return html``;\n    }\n    if (this._error) {\n      return html`<div class=\"error\">${this._error}</div>`;\n    }\n    return html`\n      <ha-card id=\"card\" .header=${this._config.title}>\n        <div id=\"root\">\n          <ha-map\n            .hass=${this.hass}\n            .entities=${this._getEntities(\n              this.hass.states,\n              this._config,\n              this._configEntities\n            )}\n            .zoom=${this._config.default_zoom ?? 14}\n            .paths=${this._getHistoryPaths(this._config, this._stateHistory)}\n            .autoFit=${this._config.auto_fit}\n            .darkMode=${this._config.dark_mode}\n          ></ha-map>\n          <ha-icon-button\n            .label=${this.hass!.localize(\n              \"ui.panel.lovelace.cards.map.reset_focus\"\n            )}\n            .path=${mdiImageFilterCenterFocus}\n            @click=${this._fitMap}\n            tabindex=\"0\"\n          ></ha-icon-button>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    if (!changedProps.has(\"hass\") || changedProps.size > 1) {\n      return true;\n    }\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (!oldHass || !this._configEntities) {\n      return true;\n    }\n\n    if (oldHass.themes.darkMode !== this.hass.themes.darkMode) {\n      return true;\n    }\n\n    if (changedProps.has(\"_stateHistory\")) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated && this._configEntities?.length) {\n      this._subscribeHistory();\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._unsubscribeHistory();\n  }\n\n  private _subscribeHistory() {\n    if (!isComponentLoaded(this.hass!, \"history\") || this._subscribed) {\n      return;\n    }\n    this._subscribed = subscribeHistoryStatesTimeWindow(\n      this.hass!,\n      (combinedHistory) => {\n        if (!this._subscribed) {\n          // Message came in before we had a chance to unload\n          return;\n        }\n        this._stateHistory = combinedHistory;\n      },\n      this._config!.hours_to_show! ?? DEFAULT_HOURS_TO_SHOW,\n      this._configEntities!,\n      false,\n      false\n    ).catch((err) => {\n      this._subscribed = undefined;\n      this._error = err;\n    });\n  }\n\n  private _unsubscribeHistory() {\n    if (this._subscribed) {\n      this._subscribed.then((unsub) => unsub?.());\n      this._subscribed = undefined;\n    }\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (this._configEntities?.length) {\n      if (!this._subscribed || changedProps.has(\"_config\")) {\n        this._unsubscribeHistory();\n        this._subscribeHistory();\n      }\n    } else {\n      this._unsubscribeHistory();\n    }\n    if (changedProps.has(\"_config\")) {\n      this._computePadding();\n    }\n  }\n\n  private _computePadding(): void {\n    const root = this.shadowRoot!.getElementById(\"root\");\n    if (!this._config || this.isPanel || !root) {\n      return;\n    }\n\n    if (!this._config.aspect_ratio) {\n      root.style.paddingBottom = \"100%\";\n      return;\n    }\n\n    root.style.height = \"auto\";\n\n    const ratio = parseAspectRatio(this._config.aspect_ratio);\n\n    root.style.paddingBottom =\n      ratio && ratio.w > 0 && ratio.h > 0\n        ? `${((100 * ratio.h) / ratio.w).toFixed(2)}%`\n        : (root.style.paddingBottom = \"100%\");\n  }\n\n  private _fitMap() {\n    this._map?.fitMap();\n  }\n\n  private _getColor(entityId: string): string {\n    let color = this._colorDict[entityId];\n    if (color) {\n      return color;\n    }\n    color = getColorByIndex(this._colorIndex);\n    this._colorIndex++;\n    this._colorDict[entityId] = color;\n    return color;\n  }\n\n  private _getEntities = memoizeOne(\n    (\n      states: HassEntities,\n      config: MapCardConfig,\n      configEntities?: string[]\n    ) => {\n      if (!states || !config) {\n        return undefined;\n      }\n\n      let entities = configEntities || [];\n\n      if (config.geo_location_sources) {\n        const geoEntities: string[] = [];\n        // Calculate visible geo location sources\n        const includesAll = config.geo_location_sources.includes(\"all\");\n        for (const stateObj of Object.values(states)) {\n          if (\n            computeDomain(stateObj.entity_id) === \"geo_location\" &&\n            (includesAll ||\n              config.geo_location_sources.includes(stateObj.attributes.source))\n          ) {\n            geoEntities.push(stateObj.entity_id);\n          }\n        }\n\n        entities = [...entities, ...geoEntities];\n      }\n\n      return entities.map((entity) => ({\n        entity_id: entity,\n        color: this._getColor(entity),\n      }));\n    }\n  );\n\n  private _getHistoryPaths = memoizeOne(\n    (\n      config: MapCardConfig,\n      history?: HistoryStates\n    ): HaMapPaths[] | undefined => {\n      if (!history) {\n        return undefined;\n      }\n\n      const paths: HaMapPaths[] = [];\n\n      for (const entityId of Object.keys(history)) {\n        const entityStates = history[entityId];\n        if (!entityStates?.length) {\n          continue;\n        }\n        // filter location data from states and remove all invalid locations\n        const points: HaMapPathPoint[] = [];\n        for (const entityState of entityStates) {\n          const latitude = entityState.a.latitude;\n          const longitude = entityState.a.longitude;\n          if (!latitude || !longitude) {\n            continue;\n          }\n          const p = {} as HaMapPathPoint;\n          p.point = [latitude, longitude] as LatLngTuple;\n          const t = new Date(entityState.lu * 1000);\n          if ((config.hours_to_show! ?? DEFAULT_HOURS_TO_SHOW) > 144) {\n            // if showing > 6 days in the history trail, show the full\n            // date and time\n            p.tooltip = formatDateTime(t, this.hass.locale);\n          } else if (isToday(t)) {\n            p.tooltip = formatTime(t, this.hass.locale);\n          } else {\n            p.tooltip = formatTimeWeekday(t, this.hass.locale);\n          }\n          points.push(p);\n        }\n        paths.push({\n          points,\n          color: this._getColor(entityId),\n          gradualOpacity: 0.8,\n        });\n      }\n      return paths;\n    }\n  );\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n        display: flex;\n        flex-direction: column;\n      }\n\n      ha-map {\n        z-index: 0;\n        border: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: inherit;\n      }\n\n      ha-icon-button {\n        position: absolute;\n        top: 75px;\n        left: 3px;\n        outline: none;\n      }\n\n      #root {\n        position: relative;\n        height: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-map-card\": HuiMapCard;\n  }\n}\n"],"names":[],"sourceRoot":""}