{"version":3,"file":"37a15965.js","mappings":";AA2HA;AAMA;;AAUA;AACA;AACA;AACA;;AAZA;AACA;AAfA;AACA;AA4BA;;;;;;;;;;AAgTA;ACxQA;;AAEA;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAnBA;;;;;;;;;;AAgGA","sources":["webpack://home-assistant-frontend/./src/components/chart/statistics-chart.ts","webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-statistics-graph-card.ts"],"sourcesContent":["import type {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ChartType,\n} from \"chart.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../common/number/format_number\";\nimport {\n  getDisplayUnit,\n  getStatisticLabel,\n  getStatisticMetadata,\n  Statistics,\n  statisticsHaveType,\n  StatisticsMetaData,\n  StatisticType,\n} from \"../../data/recorder\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-chart-base\";\n\nexport type ExtendedStatisticType = StatisticType | \"change\";\n\nexport const supportedStatTypeMap: Record<\n  ExtendedStatisticType,\n  StatisticType\n> = {\n  mean: \"mean\",\n  min: \"min\",\n  max: \"max\",\n  sum: \"sum\",\n  state: \"sum\",\n  change: \"sum\",\n};\n\nexport const statTypeMap: Record<ExtendedStatisticType, StatisticType> = {\n  mean: \"mean\",\n  min: \"min\",\n  max: \"max\",\n  sum: \"sum\",\n  state: \"state\",\n  change: \"sum\",\n};\n\n@customElement(\"statistics-chart\")\nclass StatisticsChart extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public statisticsData?: Statistics;\n\n  @property({ attribute: false }) public metadata?: Record<\n    string,\n    StatisticsMetaData\n  >;\n\n  @property() public names?: Record<string, string>;\n\n  @property() public unit?: string;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @property({ type: Array }) public statTypes: Array<ExtendedStatisticType> = [\n    \"sum\",\n    \"min\",\n    \"mean\",\n    \"max\",\n  ];\n\n  @property() public chartType: ChartType = \"line\";\n\n  @property({ type: Boolean }) public hideLegend = false;\n\n  @property({ type: Boolean }) public isLoadingData = false;\n\n  @state() private _chartData: ChartData = { datasets: [] };\n\n  @state() private _chartOptions?: ChartOptions;\n\n  private _computedStyle?: CSSStyleDeclaration;\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return changedProps.size > 1 || !changedProps.has(\"hass\");\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated || changedProps.has(\"unit\")) {\n      this._createOptions();\n    }\n    if (\n      changedProps.has(\"statisticsData\") ||\n      changedProps.has(\"statTypes\") ||\n      changedProps.has(\"hideLegend\")\n    ) {\n      this._generateData();\n    }\n  }\n\n  public firstUpdated() {\n    this._computedStyle = getComputedStyle(this);\n  }\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"history\")) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n    }\n\n    if (this.isLoadingData && !this.statisticsData) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.loading_statistics\"\n        )}\n      </div>`;\n    }\n\n    if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.no_statistics_found\"\n        )}\n      </div>`;\n    }\n\n    return html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n  }\n\n  private _createOptions(unit?: string) {\n    this._chartOptions = {\n      parsing: false,\n      animation: false,\n      scales: {\n        x: {\n          type: \"time\",\n          adapters: {\n            date: {\n              locale: this.hass.locale,\n            },\n          },\n          ticks: {\n            maxRotation: 0,\n            sampleSize: 5,\n            autoSkipPadding: 20,\n            major: {\n              enabled: true,\n            },\n            font: (context) =>\n              context.tick && context.tick.major\n                ? ({ weight: \"bold\" } as any)\n                : {},\n          },\n          time: {\n            tooltipFormat: \"datetime\",\n          },\n        },\n        y: {\n          beginAtZero: false,\n          ticks: {\n            maxTicksLimit: 7,\n          },\n          title: {\n            display: unit || this.unit,\n            text: unit || this.unit,\n          },\n        },\n      },\n      plugins: {\n        tooltip: {\n          mode: \"nearest\",\n          callbacks: {\n            label: (context) =>\n              `${context.dataset.label}: ${formatNumber(\n                context.parsed.y,\n                this.hass.locale\n              )} ${\n                // @ts-ignore\n                context.dataset.unit || \"\"\n              }`,\n          },\n        },\n        filler: {\n          propagate: true,\n        },\n        legend: {\n          display: !this.hideLegend,\n          labels: {\n            usePointStyle: true,\n          },\n        },\n      },\n      hover: {\n        mode: \"nearest\",\n      },\n      elements: {\n        line: {\n          tension: 0.4,\n          cubicInterpolationMode: \"monotone\",\n          borderWidth: 1.5,\n        },\n        bar: { borderWidth: 1.5, borderRadius: 4 },\n        point: {\n          hitRadius: 5,\n        },\n      },\n      // @ts-expect-error\n      locale: numberFormatToLocale(this.hass.locale),\n    };\n  }\n\n  private _getStatisticsMetaData = memoizeOne(\n    async (statisticIds: string[] | undefined) => {\n      const statsMetadataArray = await getStatisticMetadata(\n        this.hass,\n        statisticIds\n      );\n      const statisticsMetaData = {};\n      statsMetadataArray.forEach((x) => {\n        statisticsMetaData[x.statistic_id] = x;\n      });\n      return statisticsMetaData;\n    }\n  );\n\n  private async _generateData() {\n    if (!this.statisticsData) {\n      return;\n    }\n\n    const statisticsMetaData =\n      this.metadata ||\n      (await this._getStatisticsMetaData(Object.keys(this.statisticsData)));\n\n    let colorIndex = 0;\n    const statisticsData = Object.entries(this.statisticsData);\n    const totalDataSets: ChartDataset<\"line\">[] = [];\n    let endTime: Date;\n\n    if (statisticsData.length === 0) {\n      return;\n    }\n\n    endTime =\n      this.endTime ||\n      // Get the highest date from the last date of each statistic\n      new Date(\n        Math.max(\n          ...statisticsData.map(([_, stats]) =>\n            new Date(stats[stats.length - 1].start).getTime()\n          )\n        )\n      );\n\n    if (endTime > new Date()) {\n      endTime = new Date();\n    }\n\n    let unit: string | undefined | null;\n\n    const names = this.names || {};\n    statisticsData.forEach(([statistic_id, stats]) => {\n      const meta = statisticsMetaData?.[statistic_id];\n      let name = names[statistic_id];\n      if (name === undefined) {\n        name = getStatisticLabel(this.hass, statistic_id, meta);\n      }\n\n      if (!this.unit) {\n        if (unit === undefined) {\n          unit = getDisplayUnit(this.hass, statistic_id, meta);\n        } else if (\n          unit !== null &&\n          unit !== getDisplayUnit(this.hass, statistic_id, meta)\n        ) {\n          // Clear unit if not all statistics have same unit\n          unit = null;\n        }\n      }\n\n      // array containing [value1, value2, etc]\n      let prevValues: Array<number | null> | null = null;\n      let prevEndTime: Date | undefined;\n\n      // The datasets for the current statistic\n      const statDataSets: ChartDataset<\"line\">[] = [];\n\n      const pushData = (\n        start: Date,\n        end: Date,\n        dataValues: Array<number | null> | null\n      ) => {\n        if (!dataValues) return;\n        if (start > end) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        statDataSets.forEach((d, i) => {\n          if (\n            prevEndTime &&\n            prevValues &&\n            prevEndTime.getTime() !== start.getTime()\n          ) {\n            // if the end of the previous data doesn't match the start of the current data,\n            // we have to draw a gap so add a value at the end time, and then an empty value.\n            d.data.push({ x: prevEndTime.getTime(), y: prevValues[i]! });\n            // @ts-expect-error\n            d.data.push({ x: prevEndTime.getTime(), y: null });\n          }\n          d.data.push({ x: start.getTime(), y: dataValues[i]! });\n        });\n        prevValues = dataValues;\n        prevEndTime = end;\n      };\n\n      const color = getGraphColorByIndex(colorIndex, this._computedStyle!);\n      colorIndex++;\n\n      const statTypes: this[\"statTypes\"] = [];\n\n      const drawBands =\n        this.statTypes.includes(\"mean\") && statisticsHaveType(stats, \"mean\");\n\n      const sortedTypes = drawBands\n        ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n            return 0;\n          })\n        : this.statTypes;\n\n      sortedTypes.forEach((type) => {\n        if (statisticsHaveType(stats, statTypeMap[type])) {\n          const band = drawBands && (type === \"min\" || type === \"max\");\n          statTypes.push(type);\n          statDataSets.push({\n            label: name\n              ? `${name} (${this.hass.localize(\n                  `ui.components.statistics_charts.statistic_types.${type}`\n                )})\n            `\n              : this.hass.localize(\n                  `ui.components.statistics_charts.statistic_types.${type}`\n                ),\n            fill: drawBands\n              ? type === \"min\"\n                ? \"+1\"\n                : type === \"max\"\n                ? \"-1\"\n                : false\n              : false,\n            borderColor: band ? color + (this.hideLegend ? \"00\" : \"7F\") : color,\n            backgroundColor: band ? color + \"3F\" : color + \"7F\",\n            pointRadius: 0,\n            data: [],\n            // @ts-ignore\n            unit: meta?.unit_of_measurement,\n            band,\n          });\n        }\n      });\n\n      let prevDate: Date | null = null;\n      // Process chart data.\n      let firstSum: number | null | undefined = null;\n      let prevSum: number | null | undefined = null;\n      stats.forEach((stat) => {\n        const startDate = new Date(stat.start);\n        if (prevDate === startDate) {\n          return;\n        }\n        prevDate = startDate;\n        const dataValues: Array<number | null> = [];\n        statTypes.forEach((type) => {\n          let val: number | null | undefined;\n          if (type === \"sum\") {\n            if (firstSum === null || firstSum === undefined) {\n              val = 0;\n              firstSum = stat.sum;\n            } else {\n              val = (stat.sum || 0) - firstSum;\n            }\n          } else if (type === \"change\") {\n            if (prevSum === null || prevSum === undefined) {\n              prevSum = stat.sum;\n              return;\n            }\n            val = (stat.sum || 0) - prevSum;\n            prevSum = stat.sum;\n          } else {\n            val = stat[type];\n          }\n          dataValues.push(\n            val !== null && val !== undefined\n              ? Math.round(val * 100) / 100\n              : null\n          );\n        });\n        pushData(startDate, new Date(stat.end), dataValues);\n      });\n\n      // Concat two arrays\n      Array.prototype.push.apply(totalDataSets, statDataSets);\n    });\n\n    if (unit) {\n      this._createOptions(unit);\n    }\n\n    this._chartData = {\n      datasets: totalDataSets,\n    };\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"statistics-chart\": StatisticsChart;\n  }\n}\n","import { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport {\n  ExtendedStatisticType,\n  statTypeMap,\n} from \"../../../components/chart/statistics-chart\";\nimport \"../../../components/ha-card\";\nimport {\n  fetchStatistics,\n  getDisplayUnit,\n  getStatisticMetadata,\n  Statistics,\n  StatisticsMetaData,\n} from \"../../../data/recorder\";\nimport { HomeAssistant } from \"../../../types\";\nimport { findEntities } from \"../common/find-entities\";\nimport { hasConfigOrEntitiesChanged } from \"../common/has-changed\";\nimport { processConfigEntities } from \"../common/process-config-entities\";\nimport { LovelaceCard } from \"../types\";\nimport { StatisticsGraphCardConfig } from \"./types\";\n\n@customElement(\"hui-statistics-graph-card\")\nexport class HuiStatisticsGraphCard extends LitElement implements LovelaceCard {\n  public static async getConfigElement() {\n    await import(\"../editor/config-elements/hui-statistics-graph-card-editor\");\n    return document.createElement(\"hui-statistics-graph-card-editor\");\n  }\n\n  public static getStubConfig(\n    hass: HomeAssistant,\n    entities: string[],\n    entitiesFill: string[]\n  ): StatisticsGraphCardConfig {\n    const includeDomains = [\"sensor\"];\n    const maxEntities = 1;\n    const foundEntities = findEntities(\n      hass,\n      maxEntities,\n      entities,\n      entitiesFill,\n      includeDomains,\n      (stateObj: HassEntity) => \"state_class\" in stateObj.attributes\n    );\n    return {\n      type: \"statistics-graph\",\n      entities: foundEntities.length ? [foundEntities[0]] : [],\n    };\n  }\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _config?: StatisticsGraphCardConfig;\n\n  @state() private _statistics?: Statistics;\n\n  @state() private _metadata?: Record<string, StatisticsMetaData>;\n\n  @state() private _unit?: string;\n\n  private _entities: string[] = [];\n\n  private _names: Record<string, string> = {};\n\n  private _interval?: number;\n\n  private _statTypes?: Array<ExtendedStatisticType>;\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = undefined;\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (!this.hasUpdated) {\n      return;\n    }\n    this._setFetchStatisticsTimer();\n  }\n\n  public getCardSize(): number {\n    return (\n      5 +\n      (this._config?.title ? 2 : 0) +\n      (!this._config?.hide_legend ? this._entities?.length || 0 : 0)\n    );\n  }\n\n  public setConfig(config: StatisticsGraphCardConfig): void {\n    if (!config.entities || !Array.isArray(config.entities)) {\n      throw new Error(\"Entities need to be an array\");\n    }\n\n    if (!config.entities.length) {\n      throw new Error(\"You must include at least one entity\");\n    }\n\n    const configEntities = config.entities\n      ? processConfigEntities(config.entities, false)\n      : [];\n\n    this._entities = [];\n    configEntities.forEach((entity) => {\n      this._entities.push(entity.entity);\n      if (entity.name) {\n        this._names[entity.entity] = entity.name;\n      }\n    });\n\n    if (typeof config.stat_types === \"string\") {\n      this._statTypes = [config.stat_types];\n    } else if (!config.stat_types) {\n      this._statTypes = [\"state\", \"sum\", \"min\", \"max\", \"mean\"];\n    } else {\n      this._statTypes = config.stat_types;\n    }\n    this._config = config;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.has(\"_statistics\")) {\n      return true;\n    }\n    return hasConfigOrEntitiesChanged(this, changedProps);\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (!this._config || !changedProps.has(\"_config\")) {\n      return;\n    }\n\n    const oldConfig = changedProps.get(\"_config\") as\n      | StatisticsGraphCardConfig\n      | undefined;\n\n    if (\n      changedProps.has(\"_config\") &&\n      oldConfig?.entities !== this._config.entities\n    ) {\n      this._getStatisticsMetaData(this._entities).then(() => {\n        this._setFetchStatisticsTimer();\n      });\n      return;\n    }\n\n    if (\n      changedProps.has(\"_config\") &&\n      (oldConfig?.stat_types !== this._config.stat_types ||\n        oldConfig?.days_to_show !== this._config.days_to_show ||\n        oldConfig?.period !== this._config.period ||\n        oldConfig?.unit !== this._config.unit)\n    ) {\n      this._setFetchStatisticsTimer();\n    }\n  }\n\n  private _setFetchStatisticsTimer() {\n    this._getStatistics();\n    // statistics are created every hour\n    clearInterval(this._interval);\n    this._interval = window.setInterval(\n      () => this._getStatistics(),\n      this._intervalTimeout\n    );\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card .header=${this._config.title}>\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <statistics-chart\n            .hass=${this.hass}\n            .isLoadingData=${!this._statistics}\n            .statisticsData=${this._statistics}\n            .metadata=${this._metadata}\n            .chartType=${this._config.chart_type || \"line\"}\n            .statTypes=${this._statTypes!}\n            .names=${this._names}\n            .unit=${this._unit}\n            .hideLegend=${this._config.hide_legend || false}\n          ></statistics-chart>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private get _intervalTimeout(): number {\n    return (this._config?.period === \"5minute\" ? 5 : 60) * 1000 * 60;\n  }\n\n  private async _getStatisticsMetaData(statisticIds: string[] | undefined) {\n    const statsMetadataArray = await getStatisticMetadata(\n      this.hass!,\n      statisticIds\n    );\n    const statisticsMetaData = {};\n    statsMetadataArray.forEach((x) => {\n      statisticsMetaData[x.statistic_id] = x;\n    });\n    this._metadata = statisticsMetaData;\n  }\n\n  private async _getStatistics(): Promise<void> {\n    const startDate = new Date();\n    startDate.setTime(\n      startDate.getTime() -\n        1000 * 60 * 60 * (24 * (this._config!.days_to_show || 30) + 1)\n    );\n    try {\n      let unitClass;\n      if (this._config!.unit && this._metadata) {\n        const metadata = Object.values(this._metadata).find(\n          (metaData) =>\n            getDisplayUnit(this.hass!, metaData?.statistic_id, metaData) ===\n            this._config!.unit\n        );\n        if (metadata) {\n          unitClass = metadata.unit_class;\n          this._unit = this._config!.unit;\n        }\n      }\n      if (!unitClass && this._metadata) {\n        const metadata = this._metadata[this._entities[0]];\n        unitClass = metadata?.unit_class;\n        this._unit = unitClass\n          ? getDisplayUnit(this.hass!, metadata.statistic_id, metadata) ||\n            undefined\n          : undefined;\n      }\n      const unitconfig = unitClass ? { [unitClass]: this._unit } : undefined;\n      this._statistics = await fetchStatistics(\n        this.hass!,\n        startDate,\n        undefined,\n        this._entities,\n        this._config!.period,\n        unitconfig,\n        this._statTypes?.map((stat_type) => statTypeMap[stat_type])\n      );\n    } catch (err) {\n      this._statistics = undefined;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-statistics-graph-card\": HuiStatisticsGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}