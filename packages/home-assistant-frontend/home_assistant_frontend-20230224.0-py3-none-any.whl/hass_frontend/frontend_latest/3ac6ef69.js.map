{"version":3,"file":"3ac6ef69.js","mappings":";;;AAgLA;AACA;AACA;AACA;AACA;AACA;AAEA","sources":["webpack://home-assistant-frontend/mwc-menu-surface-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport {MDCMenuSurfaceAdapter} from '@material/menu-surface/adapter.js';\nimport {Corner as CornerEnum, CornerBit} from '@material/menu-surface/constants.js';\nimport MDCMenuSurfaceFoundation from '@material/menu-surface/foundation.js';\nimport {addHasRemoveClass, BaseElement} from '@material/mwc-base/base-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {deepActiveElementPath, doesElementContainFocus} from '@material/mwc-base/utils.js';\nimport {html} from 'lit';\nimport {property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nexport type Corner = keyof typeof CornerEnum;\nexport type AnchorableElement = HTMLElement&{anchor: Element | null};\nexport type MenuCorner = 'START'|'END';\n\n// tslint:disable:no-bitwise\n\n// required for closure compiler\nconst stringToCorner = {\n  'TOP_LEFT': CornerEnum.TOP_LEFT,\n  'TOP_RIGHT': CornerEnum.TOP_RIGHT,\n  'BOTTOM_LEFT': CornerEnum.BOTTOM_LEFT,\n  'BOTTOM_RIGHT': CornerEnum.BOTTOM_RIGHT,\n  'TOP_START': CornerEnum.TOP_START,\n  'TOP_END': CornerEnum.TOP_END,\n  'BOTTOM_START': CornerEnum.BOTTOM_START,\n  'BOTTOM_END': CornerEnum.BOTTOM_END,\n};\n\n/**\n * @fires opened\n * @fires closed\n */\nexport abstract class MenuSurfaceBase extends BaseElement {\n  protected mdcFoundation!: MDCMenuSurfaceFoundation;\n\n  protected readonly mdcFoundationClass = MDCMenuSurfaceFoundation;\n\n  @query('.mdc-menu-surface') mdcRoot!: HTMLDivElement;\n\n  @query('slot') slotElement!: HTMLSlotElement|null;\n\n  @property({type: Boolean})\n  @observer(function(this: MenuSurfaceBase, isAbsolute: boolean) {\n    if (this.mdcFoundation && !this.fixed) {\n      this.mdcFoundation.setIsHoisted(isAbsolute);\n    }\n  })\n  absolute = false;\n\n  @property({type: Boolean}) fullwidth = false;\n\n  @property({type: Boolean})\n  @observer(function(this: MenuSurfaceBase, isFixed: boolean) {\n    if (this.mdcFoundation && !this.absolute) {\n      this.mdcFoundation.setFixedPosition(isFixed);\n    }\n  })\n  fixed = false;\n\n  @property({type: Number})\n  @observer(function(this: MenuSurfaceBase, value: number|null) {\n    if (this.mdcFoundation && this.y !== null && value !== null) {\n      this.mdcFoundation.setAbsolutePosition(value, this.y);\n      this.mdcFoundation.setAnchorMargin(\n          {left: value, top: this.y, right: -value, bottom: this.y});\n    }\n  })\n  x: number|null = null;\n\n  @property({type: Number})\n  @observer(function(this: MenuSurfaceBase, value: number|null) {\n    if (this.mdcFoundation && this.x !== null && value !== null) {\n      this.mdcFoundation.setAbsolutePosition(this.x, value);\n      this.mdcFoundation.setAnchorMargin(\n          {left: this.x, top: value, right: -this.x, bottom: value});\n    }\n  })\n  y: number|null = null;\n\n  // must be defined before open or else race condition in foundation occurs.\n  @property({type: Boolean})\n  @observer(function(this: MenuSurfaceBase, value: boolean) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setQuickOpen(value);\n    }\n  })\n  quick = false;\n\n  @property({type: Boolean, reflect: true})\n  @observer(function(this: MenuSurfaceBase, isOpen: boolean, wasOpen: boolean) {\n    this.onOpenChanged(isOpen, wasOpen);\n  })\n  open = false;\n\n  @property({type: Boolean}) stayOpenOnBodyClick: boolean = false;\n\n  @state()\n  @observer(function(this: MenuSurfaceBase, value: CornerEnum) {\n    if (this.mdcFoundation) {\n      if (value) {\n        this.mdcFoundation.setAnchorCorner(value);\n      } else {\n        this.mdcFoundation.setAnchorCorner(value);\n      }\n    }\n  })\n\n  protected bitwiseCorner: CornerEnum = CornerEnum.TOP_START;\n  protected previousMenuCorner: MenuCorner|null = null;\n\n  // must be defined before observer of anchor corner for initialization\n  @property({type: String})\n  @observer(function(this: MenuSurfaceBase, value: MenuCorner) {\n    if (this.mdcFoundation) {\n      const isValidValue = value === 'START' || value === 'END';\n      const isFirstTimeSet = this.previousMenuCorner === null;\n      const cornerChanged =\n          !isFirstTimeSet && value !== this.previousMenuCorner;\n      const initiallySetToEnd = isFirstTimeSet && value === 'END';\n\n      if (isValidValue && (cornerChanged || initiallySetToEnd)) {\n        this.bitwiseCorner = this.bitwiseCorner ^ CornerBit.RIGHT;\n        this.mdcFoundation.flipCornerHorizontally();\n        this.previousMenuCorner = value;\n      }\n    }\n  })\n  menuCorner: MenuCorner = 'START';\n\n  @property({type: String})\n  @observer(function(this: MenuSurfaceBase, value: Corner) {\n    if (this.mdcFoundation) {\n      if (value) {\n        let newCorner = stringToCorner[value];\n        if (this.menuCorner === 'END') {\n          newCorner = newCorner ^ CornerBit.RIGHT;\n        }\n\n        this.bitwiseCorner = newCorner;\n      }\n    }\n  })\n  corner: Corner = 'TOP_START';\n\n  @state() protected styleTop = '';\n  @state() protected styleLeft = '';\n  @state() protected styleRight = '';\n  @state() protected styleBottom = '';\n  @state() protected styleMaxHeight = '';\n  @state() protected styleTransformOrigin = '';\n\n  anchor: HTMLElement|null = null;\n\n  protected previouslyFocused: HTMLElement|Element|null = null;\n  protected previousAnchor: HTMLElement|null = null;\n  protected onBodyClickBound: (evt: MouseEvent) => void = () => undefined;\n\n  override render() {\n    return this.renderSurface();\n  }\n\n  protected renderSurface() {\n    const classes = this.getRootClasses();\n    const styles = this.getRootStyles();\n    return html`\n      <div\n          class=${classMap(classes)}\n          style=\"${styleMap(styles)}\"\n          @keydown=${this.onKeydown}\n          @opened=${this.registerBodyClick}\n          @closed=${this.deregisterBodyClick}>\n        ${this.renderContent()}\n      </div>`;\n  }\n\n  protected getRootClasses() {\n    return {\n      'mdc-menu-surface': true,\n      'mdc-menu-surface--fixed': this.fixed,\n      'mdc-menu-surface--fullwidth': this.fullwidth,\n    };\n  }\n\n  protected getRootStyles() {\n    return {\n      'top': this.styleTop,\n      'left': this.styleLeft,\n      'right': this.styleRight,\n      'bottom': this.styleBottom,\n      'max-height': this.styleMaxHeight,\n      'transform-origin': this.styleTransformOrigin,\n    };\n  }\n\n  protected renderContent() {\n    return html`<slot></slot>`;\n  }\n\n  createAdapter(): MDCMenuSurfaceAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      hasAnchor: () => {\n        return !!this.anchor;\n      },\n      notifyClose: () => {\n        const init: CustomEventInit = {bubbles: true, composed: true};\n        const ev = new CustomEvent('closed', init);\n        this.open = false;\n        this.mdcRoot.dispatchEvent(ev);\n      },\n      notifyClosing: () => {\n        const init: CustomEventInit = {bubbles: true, composed: true};\n        const ev = new CustomEvent('closing', init);\n        this.mdcRoot.dispatchEvent(ev);\n      },\n      notifyOpen: () => {\n        const init: CustomEventInit = {bubbles: true, composed: true};\n        const ev = new CustomEvent('opened', init);\n        this.open = true;\n        this.mdcRoot.dispatchEvent(ev);\n      },\n      notifyOpening: () => {\n        const init: CustomEventInit = {bubbles: true, composed: true};\n        const ev = new CustomEvent('opening', init);\n        this.mdcRoot.dispatchEvent(ev);\n      },\n      isElementInContainer: () => false,\n      isRtl: () => {\n        if (this.mdcRoot) {\n          return getComputedStyle(this.mdcRoot).direction === 'rtl';\n        }\n\n        return false;\n      },\n      setTransformOrigin: (origin) => {\n        const root = this.mdcRoot;\n        if (!root) {\n          return;\n        }\n\n        this.styleTransformOrigin = origin;\n      },\n      isFocused: () => {\n        return doesElementContainFocus(this);\n      },\n      saveFocus: () => {\n        const activeElementPath = deepActiveElementPath();\n        const pathLength = activeElementPath.length;\n\n        if (!pathLength) {\n          this.previouslyFocused = null;\n        }\n\n        this.previouslyFocused = activeElementPath[pathLength - 1];\n      },\n      restoreFocus: () => {\n        if (!this.previouslyFocused) {\n          return;\n        }\n\n        if ('focus' in this.previouslyFocused) {\n          this.previouslyFocused.focus();\n        }\n      },\n      getInnerDimensions: () => {\n        const mdcRoot = this.mdcRoot;\n\n        if (!mdcRoot) {\n          return {width: 0, height: 0};\n        }\n\n        return {width: mdcRoot.offsetWidth, height: mdcRoot.offsetHeight};\n      },\n      getAnchorDimensions: () => {\n        const anchorElement = this.anchor;\n\n        return anchorElement ? anchorElement.getBoundingClientRect() : null;\n      },\n      getBodyDimensions: () => {\n        return {\n          width: document.body.clientWidth,\n          height: document.body.clientHeight,\n        };\n      },\n      getWindowDimensions: () => {\n        return {\n          width: window.innerWidth,\n          height: window.innerHeight,\n        };\n      },\n      getWindowScroll: () => {\n        return {\n          x: window.pageXOffset,\n          y: window.pageYOffset,\n        };\n      },\n      setPosition: (position) => {\n        const mdcRoot = this.mdcRoot;\n\n        if (!mdcRoot) {\n          return;\n        }\n\n        this.styleLeft = 'left' in position ? `${position.left}px` : '';\n        this.styleRight = 'right' in position ? `${position.right}px` : '';\n        this.styleTop = 'top' in position ? `${position.top}px` : '';\n        this.styleBottom = 'bottom' in position ? `${position.bottom}px` : '';\n      },\n      setMaxHeight: async (height) => {\n        const mdcRoot = this.mdcRoot;\n\n        if (!mdcRoot) {\n          return;\n        }\n\n        // must set both for IE support as IE will not set a var\n        this.styleMaxHeight = height;\n        await this.updateComplete;\n        this.styleMaxHeight = `var(--mdc-menu-max-height, ${height})`;\n      },\n    };\n  }\n\n  protected onKeydown(evt: KeyboardEvent) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handleKeydown(evt);\n    }\n  }\n\n  protected onBodyClick(evt: MouseEvent) {\n    if (this.stayOpenOnBodyClick) {\n      return;\n    }\n    const path = evt.composedPath();\n    if (path.indexOf(this) === -1) {\n      this.close();\n    }\n  }\n\n  protected registerBodyClick() {\n    this.onBodyClickBound = this.onBodyClick.bind(this);\n    // capture otherwise listener closes menu after quick menu opens\n    document.body.addEventListener(\n        'click', this.onBodyClickBound, {passive: true, capture: true});\n  }\n\n  protected deregisterBodyClick() {\n    document.body.removeEventListener(\n        'click', this.onBodyClickBound, {capture: true});\n  }\n\n  protected onOpenChanged(isOpen: boolean, wasOpen: boolean) {\n    if (this.mdcFoundation) {\n      if (isOpen) {\n        this.mdcFoundation.open();\n        // wasOpen helps with first render (when it is `undefined`) perf\n      } else if (wasOpen !== undefined) {\n        this.mdcFoundation.close();\n      }\n    }\n  }\n\n  close() {\n    this.open = false;\n  }\n\n  show() {\n    this.open = true;\n  }\n}\n"],"names":[],"sourceRoot":""}