{"version":3,"file":"d6f681e2.js","mappings":";;AAqBA;AACA;AACA;AACA;;;;AAIA;;AAIA;;;;;AAUA;;AAdA;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8EA;AC7EA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;;;;;;AA+CA;;;;AChGA;;;;;;;;;;;;;AC8BA;;;;;;;;;;;;;;;;;;;;;;ACVA;;AC0GA;AACA;AACA;AACA;AACA;AACA;;AAIA;;;AAIA;;AAEA;AACA;AACA;;;;AAMA;;AAGA;AAEA;AACA;AACA;AACA;;;AAMA;AACA;AACA;AAGA;AACA;;;;AAIA;;;AAKA;AACA;;;;;AAKA;;AAIA;AACA;;;;AAIA;AACA;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+PA","sources":["webpack://home-assistant-frontend/./src/components/buttons/ha-progress-button.ts","webpack://home-assistant-frontend/./src/components/ha-button-menu.ts","webpack://home-assistant-frontend/./src/components/ha-checkbox.ts","webpack://home-assistant-frontend/./src/components/ha-formfield.ts","webpack://home-assistant-frontend/./src/components/ha-list-item.ts","webpack://home-assistant-frontend/./src/panels/config/integrations/integration-panels/zha/zha-network-visualization-page.ts"],"sourcesContent":["import \"@material/mwc-button\";\nimport { mdiAlertOctagram, mdiCheckBold } from \"@mdi/js\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport \"../ha-circular-progress\";\nimport \"../ha-svg-icon\";\n\n@customElement(\"ha-progress-button\")\nexport class HaProgressButton extends LitElement {\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public progress = false;\n\n  @property({ type: Boolean }) public raised = false;\n\n  @state() private _result?: \"success\" | \"error\";\n\n  public render(): TemplateResult {\n    const overlay = this._result || this.progress;\n    return html`\n      <mwc-button\n        ?raised=${this.raised}\n        .disabled=${this.disabled || this.progress}\n        @click=${this._buttonTapped}\n        class=${this._result || \"\"}\n      >\n        <slot></slot>\n      </mwc-button>\n      ${!overlay\n        ? \"\"\n        : html`\n            <div class=\"progress\">\n              ${this._result === \"success\"\n                ? html`<ha-svg-icon .path=${mdiCheckBold}></ha-svg-icon>`\n                : this._result === \"error\"\n                ? html`<ha-svg-icon .path=${mdiAlertOctagram}></ha-svg-icon>`\n                : this.progress\n                ? html`\n                    <ha-circular-progress\n                      size=\"small\"\n                      active\n                    ></ha-circular-progress>\n                  `\n                : \"\"}\n            </div>\n          `}\n    `;\n  }\n\n  public actionSuccess(): void {\n    this._setResult(\"success\");\n  }\n\n  public actionError(): void {\n    this._setResult(\"error\");\n  }\n\n  private _setResult(result: \"success\" | \"error\"): void {\n    this._result = result;\n    setTimeout(() => {\n      this._result = undefined;\n    }, 2000);\n  }\n\n  private _buttonTapped(ev: Event): void {\n    if (this.progress) {\n      ev.stopPropagation();\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        outline: none;\n        display: inline-block;\n        position: relative;\n      }\n\n      mwc-button {\n        transition: all 1s;\n      }\n\n      mwc-button.success {\n        --mdc-theme-primary: white;\n        background-color: var(--success-color);\n        transition: none;\n        border-radius: 4px;\n        pointer-events: none;\n      }\n\n      mwc-button[raised].success {\n        --mdc-theme-primary: var(--success-color);\n        --mdc-theme-on-primary: white;\n      }\n\n      mwc-button.error {\n        --mdc-theme-primary: white;\n        background-color: var(--error-color);\n        transition: none;\n        border-radius: 4px;\n        pointer-events: none;\n      }\n\n      mwc-button[raised].error {\n        --mdc-theme-primary: var(--error-color);\n        --mdc-theme-on-primary: white;\n      }\n\n      .progress {\n        bottom: 4px;\n        position: absolute;\n        text-align: center;\n        top: 4px;\n        width: 100%;\n      }\n\n      ha-svg-icon {\n        color: white;\n      }\n\n      mwc-button.success slot,\n      mwc-button.error slot {\n        visibility: hidden;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-progress-button\": HaProgressButton;\n  }\n}\n","import type { Button } from \"@material/mwc-button\";\nimport \"@material/mwc-menu\";\nimport type { Corner, Menu, MenuCorner } from \"@material/mwc-menu\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { FOCUS_TARGET } from \"../dialogs/make-dialog-manager\";\nimport type { HaIconButton } from \"./ha-icon-button\";\n\n@customElement(\"ha-button-menu\")\nexport class HaButtonMenu extends LitElement {\n  protected readonly [FOCUS_TARGET];\n\n  @property() public corner: Corner = \"TOP_START\";\n\n  @property() public menuCorner: MenuCorner = \"START\";\n\n  @property({ type: Number }) public x: number | null = null;\n\n  @property({ type: Number }) public y: number | null = null;\n\n  @property({ type: Boolean }) public multi = false;\n\n  @property({ type: Boolean }) public activatable = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public fixed = false;\n\n  @query(\"mwc-menu\", true) private _menu?: Menu;\n\n  public get items() {\n    return this._menu?.items;\n  }\n\n  public get selected() {\n    return this._menu?.selected;\n  }\n\n  public override focus() {\n    if (this._menu?.open) {\n      this._menu.focusItemAtIndex(0);\n    } else {\n      this._triggerButton?.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div @click=${this._handleClick}>\n        <slot name=\"trigger\" @slotchange=${this._setTriggerAria}></slot>\n      </div>\n      <mwc-menu\n        .corner=${this.corner}\n        .menuCorner=${this.menuCorner}\n        .fixed=${this.fixed}\n        .multi=${this.multi}\n        .activatable=${this.activatable}\n        .y=${this.y}\n        .x=${this.x}\n      >\n        <slot></slot>\n      </mwc-menu>\n    `;\n  }\n\n  protected firstUpdated(changedProps): void {\n    super.firstUpdated(changedProps);\n\n    if (document.dir === \"rtl\") {\n      this.updateComplete.then(() => {\n        this.querySelectorAll(\"mwc-list-item\").forEach((item) => {\n          const style = document.createElement(\"style\");\n          style.innerHTML =\n            \"span.material-icons:first-of-type { margin-left: var(--mdc-list-item-graphic-margin, 32px) !important; margin-right: 0px !important;}\";\n          item!.shadowRoot!.appendChild(style);\n        });\n      });\n    }\n  }\n\n  private _handleClick(): void {\n    if (this.disabled) {\n      return;\n    }\n    this._menu!.anchor = this;\n    this._menu!.show();\n  }\n\n  private get _triggerButton() {\n    return this.querySelector(\n      'ha-icon-button[slot=\"trigger\"], mwc-button[slot=\"trigger\"]'\n    ) as HaIconButton | Button | null;\n  }\n\n  private _setTriggerAria() {\n    if (this._triggerButton) {\n      this._triggerButton.ariaHasPopup = \"menu\";\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        position: relative;\n      }\n      ::slotted([disabled]) {\n        color: var(--disabled-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button-menu\": HaButtonMenu;\n  }\n}\n","import { CheckboxBase } from \"@material/mwc-checkbox/mwc-checkbox-base\";\nimport { styles } from \"@material/mwc-checkbox/mwc-checkbox.css\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-checkbox\")\nexport class HaCheckbox extends CheckboxBase {\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--primary-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-checkbox\": HaCheckbox;\n  }\n}\n","import { FormfieldBase } from \"@material/mwc-formfield/mwc-formfield-base\";\nimport { styles } from \"@material/mwc-formfield/mwc-formfield.css\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\n\n@customElement(\"ha-formfield\")\nexport class HaFormfield extends FormfieldBase {\n  protected _labelClick() {\n    const input = this.input;\n    if (input) {\n      input.focus();\n      switch (input.tagName) {\n        case \"HA-CHECKBOX\":\n        case \"HA-RADIO\":\n          if ((input as any).disabled) {\n            break;\n          }\n          (input as any).checked = !(input as any).checked;\n          fireEvent(input, \"change\");\n          break;\n        default:\n          input.click();\n          break;\n      }\n    }\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host(:not([alignEnd])) ::slotted(ha-switch) {\n        margin-right: 10px;\n        margin-inline-end: 10px;\n        margin-inline-start: inline;\n      }\n      .mdc-form-field > label {\n        direction: var(--direction);\n        margin-inline-start: 0;\n        margin-inline-end: auto;\n        padding-inline-start: 4px;\n        padding-inline-end: 0;\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-formfield\": HaFormfield;\n  }\n}\n","import { ListItemBase } from \"@material/mwc-list/mwc-list-item-base\";\nimport { styles } from \"@material/mwc-list/mwc-list-item.css\";\nimport { css, CSSResultGroup } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-list-item\")\nexport class HaListItem extends ListItemBase {\n  static get styles(): CSSResultGroup {\n    return [\n      styles,\n      css`\n        :host {\n          padding-left: var(--mdc-list-side-padding, 20px);\n          padding-right: var(--mdc-list-side-padding, 20px);\n        }\n        :host([graphic=\"avatar\"]:not([twoLine])),\n        :host([graphic=\"icon\"]:not([twoLine])) {\n          height: 48px;\n        }\n        span.material-icons:first-of-type {\n          margin-inline-start: 0px !important;\n          margin-inline-end: var(\n            --mdc-list-item-graphic-margin,\n            16px\n          ) !important;\n          direction: var(--direction);\n        }\n        span.material-icons:last-of-type {\n          margin-inline-start: auto !important;\n          margin-inline-end: 0px !important;\n          direction: var(--direction);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-list-item\": HaListItem;\n  }\n}\n","import \"@material/mwc-button\";\nimport { css, CSSResultGroup, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport {\n  Edge,\n  EdgeOptions,\n  Network,\n  Node,\n} from \"vis-network/peer/esm/vis-network\";\nimport { navigate } from \"../../../../../common/navigate\";\nimport \"../../../../../components/search-input\";\nimport \"../../../../../components/device/ha-device-picker\";\nimport \"../../../../../components/ha-button-menu\";\nimport \"../../../../../components/ha-checkbox\";\nimport type { HaCheckbox } from \"../../../../../components/ha-checkbox\";\nimport \"../../../../../components/ha-formfield\";\nimport { DeviceRegistryEntry } from \"../../../../../data/device_registry\";\nimport {\n  fetchDevices,\n  refreshTopology,\n  ZHADevice,\n} from \"../../../../../data/zha\";\nimport \"../../../../../layouts/hass-tabs-subpage\";\nimport { PolymerChangedEvent } from \"../../../../../polymer-types\";\nimport type { HomeAssistant, Route } from \"../../../../../types\";\nimport { formatAsPaddedHex } from \"./functions\";\nimport { zhaTabs } from \"./zha-config-dashboard\";\n\n@customElement(\"zha-network-visualization-page\")\nexport class ZHANetworkVisualizationPage extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public route!: Route;\n\n  @property({ type: Boolean, reflect: true }) public narrow!: boolean;\n\n  @property({ type: Boolean }) public isWide!: boolean;\n\n  @property()\n  public zoomedDeviceIdFromURL?: string;\n\n  @state()\n  private zoomedDeviceId?: string;\n\n  @query(\"#visualization\", true)\n  private _visualization?: HTMLElement;\n\n  @state()\n  private _devices: Map<string, ZHADevice> = new Map();\n\n  @state()\n  private _devicesByDeviceId: Map<string, ZHADevice> = new Map();\n\n  @state()\n  private _nodes: Node[] = [];\n\n  @state()\n  private _network?: Network;\n\n  @state()\n  private _filter?: string;\n\n  private _autoZoom = true;\n\n  private _enablePhysics = true;\n\n  protected firstUpdated(changedProperties: PropertyValues): void {\n    super.firstUpdated(changedProperties);\n\n    // prevent zoomedDeviceIdFromURL from being restored to zoomedDeviceId after the user clears it\n    if (this.zoomedDeviceIdFromURL) {\n      this.zoomedDeviceId = this.zoomedDeviceIdFromURL;\n    }\n\n    if (this.hass) {\n      this._fetchData();\n    }\n\n    this._network = new Network(\n      this._visualization!,\n      {},\n      {\n        autoResize: true,\n        layout: {\n          improvedLayout: true,\n        },\n        physics: {\n          barnesHut: {\n            springConstant: 0,\n            avoidOverlap: 10,\n            damping: 0.09,\n          },\n        },\n        nodes: {\n          font: {\n            multi: \"html\",\n          },\n        },\n        edges: {\n          smooth: {\n            enabled: true,\n            type: \"continuous\",\n            forceDirection: \"none\",\n            roundness: 0.6,\n          },\n        },\n      }\n    );\n\n    this._network.on(\"doubleClick\", (properties) => {\n      const ieee = properties.nodes[0];\n      if (ieee) {\n        const device = this._devices.get(ieee);\n        if (device) {\n          navigate(`/config/devices/device/${device.device_reg_id}`);\n        }\n      }\n    });\n\n    this._network.on(\"click\", (properties) => {\n      const ieee = properties.nodes[0];\n      if (ieee) {\n        const device = this._devices.get(ieee);\n        if (device && this._autoZoom) {\n          this.zoomedDeviceId = device.device_reg_id;\n          this._zoomToDevice();\n        }\n      }\n    });\n\n    this._network.on(\"stabilized\", () => {\n      if (this.zoomedDeviceId) {\n        this._zoomToDevice();\n      }\n    });\n  }\n\n  protected render() {\n    return html`\n      <hass-tabs-subpage\n        .tabs=${zhaTabs}\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .isWide=${this.isWide}\n        .route=${this.route}\n        .header=${this.hass.localize(\n          \"ui.panel.config.zha.visualization.header\"\n        )}\n      >\n        ${this.narrow\n          ? html`\n              <div slot=\"header\">\n                <search-input\n                  .hass=${this.hass}\n                  class=\"header\"\n                  @value-changed=${this._handleSearchChange}\n                  .filter=${this._filter}\n                  .label=${this.hass.localize(\n                    \"ui.panel.config.zha.visualization.highlight_label\"\n                  )}\n                >\n                </search-input>\n              </div>\n            `\n          : \"\"}\n        <div class=\"header\">\n          ${!this.narrow\n            ? html`<search-input\n                .hass=${this.hass}\n                @value-changed=${this._handleSearchChange}\n                .filter=${this._filter}\n                .label=${this.hass.localize(\n                  \"ui.panel.config.zha.visualization.highlight_label\"\n                )}\n              ></search-input>`\n            : \"\"}\n          <ha-device-picker\n            .hass=${this.hass}\n            .value=${this.zoomedDeviceId}\n            .label=${this.hass.localize(\n              \"ui.panel.config.zha.visualization.zoom_label\"\n            )}\n            .deviceFilter=${this._filterDevices}\n            @value-changed=${this._onZoomToDevice}\n          ></ha-device-picker>\n          <div class=\"controls\">\n            <ha-formfield\n              .label=${this.hass!.localize(\n                \"ui.panel.config.zha.visualization.auto_zoom\"\n              )}\n            >\n              <ha-checkbox\n                @change=${this._handleAutoZoomCheckboxChange}\n                .checked=${this._autoZoom}\n              >\n              </ha-checkbox>\n            </ha-formfield>\n            <ha-formfield\n              .label=${this.hass!.localize(\n                \"ui.panel.config.zha.visualization.enable_physics\"\n              )}\n              ><ha-checkbox\n                @change=${this._handlePhysicsCheckboxChange}\n                .checked=${this._enablePhysics}\n              >\n              </ha-checkbox\n            ></ha-formfield>\n            <mwc-button @click=${this._refreshTopology}>\n              ${this.hass!.localize(\n                \"ui.panel.config.zha.visualization.refresh_topology\"\n              )}\n            </mwc-button>\n          </div>\n        </div>\n        <div id=\"visualization\"></div>\n      </hass-tabs-subpage>\n    `;\n  }\n\n  private async _fetchData() {\n    const devices = await fetchDevices(this.hass!);\n    this._devices = new Map(\n      devices.map((device: ZHADevice) => [device.ieee, device])\n    );\n    this._devicesByDeviceId = new Map(\n      devices.map((device: ZHADevice) => [device.device_reg_id, device])\n    );\n    this._updateDevices(devices);\n  }\n\n  private _updateDevices(devices: ZHADevice[]) {\n    this._nodes = [];\n    const edges: Edge[] = [];\n\n    devices.forEach((device) => {\n      this._nodes.push({\n        id: device.ieee,\n        label: this._buildLabel(device),\n        shape: this._getShape(device),\n        mass: this._getMass(device),\n      });\n      if (device.neighbors && device.neighbors.length > 0) {\n        device.neighbors.forEach((neighbor) => {\n          const idx = edges.findIndex(\n            (e) => device.ieee === e.to && neighbor.ieee === e.from\n          );\n          if (idx === -1) {\n            edges.push({\n              from: device.ieee,\n              to: neighbor.ieee,\n              label: neighbor.lqi + \"\",\n              color: this._getLQI(parseInt(neighbor.lqi)),\n            });\n          } else {\n            edges[idx].color = this._getLQI(\n              (parseInt(edges[idx].label!) + parseInt(neighbor.lqi)) / 2\n            );\n            edges[idx].label += \"/\" + neighbor.lqi;\n          }\n        });\n      }\n    });\n\n    this._network?.setData({ nodes: this._nodes, edges: edges });\n  }\n\n  private _getLQI(lqi: number): EdgeOptions[\"color\"] {\n    if (lqi > 192) {\n      return { color: \"#17ab00\", highlight: \"#17ab00\" };\n    }\n    if (lqi > 128) {\n      return { color: \"#e6b402\", highlight: \"#e6b402\" };\n    }\n    if (lqi > 80) {\n      return { color: \"#fc4c4c\", highlight: \"#fc4c4c\" };\n    }\n    return { color: \"#bfbfbf\", highlight: \"#bfbfbf\" };\n  }\n\n  private _getMass(device: ZHADevice): number {\n    if (device.device_type === \"Coordinator\") {\n      return 2;\n    }\n    if (device.device_type === \"Router\") {\n      return 4;\n    }\n    return 5;\n  }\n\n  private _getShape(device: ZHADevice): string {\n    if (device.device_type === \"Coordinator\") {\n      return \"box\";\n    }\n    if (device.device_type === \"Router\") {\n      return \"ellipse\";\n    }\n    return \"circle\";\n  }\n\n  private _buildLabel(device: ZHADevice): string {\n    let label =\n      device.user_given_name !== null\n        ? `<b>${device.user_given_name}</b>\\n`\n        : \"\";\n    label += `<b>IEEE: </b>${device.ieee}`;\n    label += `\\n<b>Device Type: </b>${device.device_type.replace(\"_\", \" \")}`;\n    if (device.nwk != null) {\n      label += `\\n<b>NWK: </b>${formatAsPaddedHex(device.nwk)}`;\n    }\n    if (device.manufacturer != null && device.model != null) {\n      label += `\\n<b>Device: </b>${device.manufacturer} ${device.model}`;\n    } else {\n      label += \"\\n<b>Device is not in <i>'zigbee.db'</i></b>\";\n    }\n    if (!device.available) {\n      label += \"\\n<b>Device is <i>Offline</i></b>\";\n    }\n    return label;\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    this._filter = ev.detail.value;\n    const filterText = this._filter!.toLowerCase();\n    if (!this._network) {\n      return;\n    }\n    if (this._filter) {\n      const filteredNodeIds: (string | number)[] = [];\n      this._nodes.forEach((node) => {\n        if (node.label && node.label.toLowerCase().includes(filterText)) {\n          filteredNodeIds.push(node.id!);\n        }\n      });\n      this.zoomedDeviceId = \"\";\n      this._zoomOut();\n      this._network.selectNodes(filteredNodeIds, true);\n    } else {\n      this._network.unselectAll();\n    }\n  }\n\n  private _onZoomToDevice(event: PolymerChangedEvent<string>) {\n    event.stopPropagation();\n    this.zoomedDeviceId = event.detail.value;\n    if (!this._network) {\n      return;\n    }\n    this._zoomToDevice();\n  }\n\n  private _zoomToDevice() {\n    this._filter = \"\";\n    if (!this.zoomedDeviceId) {\n      this._zoomOut();\n    } else {\n      const device: ZHADevice | undefined = this._devicesByDeviceId.get(\n        this.zoomedDeviceId\n      );\n      if (device) {\n        this._network!.fit({\n          nodes: [device.ieee],\n          animation: { duration: 500, easingFunction: \"easeInQuad\" },\n        });\n      }\n    }\n  }\n\n  private _zoomOut() {\n    this._network!.fit({\n      nodes: [],\n      animation: { duration: 500, easingFunction: \"easeOutQuad\" },\n    });\n  }\n\n  private async _refreshTopology(): Promise<void> {\n    await refreshTopology(this.hass);\n  }\n\n  private _filterDevices = (device: DeviceRegistryEntry): boolean => {\n    if (!this.hass) {\n      return false;\n    }\n    for (const parts of device.identifiers) {\n      for (const part of parts) {\n        if (part === \"zha\") {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  private _handleAutoZoomCheckboxChange(ev: Event) {\n    this._autoZoom = (ev.target as HaCheckbox).checked;\n  }\n\n  private _handlePhysicsCheckboxChange(ev: Event) {\n    this._enablePhysics = (ev.target as HaCheckbox).checked;\n\n    this._network!.setOptions(\n      this._enablePhysics\n        ? {\n            physics: {\n              barnesHut: {\n                springConstant: 0,\n                avoidOverlap: 10,\n                damping: 0.09,\n              },\n            },\n          }\n        : { physics: false }\n    );\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        .header {\n          border-bottom: 1px solid var(--divider-color);\n          padding: 0 8px;\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n          height: var(--header-height);\n          box-sizing: border-box;\n        }\n\n        .header > * {\n          padding: 0 8px;\n        }\n\n        :host([narrow]) .header {\n          flex-direction: column;\n          align-items: stretch;\n          height: var(--header-height) * 2;\n        }\n\n        .search-toolbar {\n          display: flex;\n          align-items: center;\n          color: var(--secondary-text-color);\n          padding: 0 16px;\n        }\n\n        search-input {\n          flex: 1;\n          display: block;\n        }\n\n        search-input.header {\n          color: var(--secondary-text-color);\n        }\n\n        ha-device-picker {\n          flex: 1;\n        }\n\n        .controls {\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n        }\n\n        #visualization {\n          height: calc(100% - var(--header-height));\n          width: 100%;\n        }\n        :host([narrow]) #visualization {\n          height: calc(100% - (var(--header-height) * 2));\n        }\n      `,\n    ];\n  }\n}\n"],"names":[],"sourceRoot":""}