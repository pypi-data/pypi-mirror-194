{"version":3,"file":"367488d1.js","mappings":";;AAkKA;AACA;AACA;AACA;;AAOA;AAEA;AAcA;;AAGA;;;AAOA;;AAMA;AAEA;;;;;;;AAeA;;;;;;AC7MA;;ACsIA;AACA;AACA;AACA;AACA;;;AAMA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;;;AAwGA;;;;ACnHA;;;AAKA;;AAGA;;AAIA;;AAGA;;;;;;;AAcA;AACA;;AAGA;;AAIA;;;AAIA;;AAGA;;;AAKA;AACA;AACA;;AAEA;;AAGA;;;AAKA;AACA;;;AAGA;;AAIA;;;AAIA;AACA;;;;;AAKA;;;;AAMA;AAEA;AACA;;;AAIA;AAGA;AAEA;AACA;;;;AAKA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6JA","sources":["webpack://home-assistant-frontend/mwc-list-item-base.ts","webpack://home-assistant-frontend/./src/components/ha-button.ts","webpack://home-assistant-frontend/./src/panels/lovelace/editor/config-elements/hui-tile-card-editor.ts","webpack://home-assistant-frontend/./src/panels/lovelace/editor/config-elements/hui-tile-card-features-editor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n\nimport '@material/mwc-ripple/mwc-ripple.js';\n\nimport {observer} from '@material/mwc-base/observer.js';\nimport {Ripple} from '@material/mwc-ripple/mwc-ripple.js';\nimport {RippleHandlers} from '@material/mwc-ripple/ripple-handlers.js';\nimport {html, LitElement} from 'lit';\nimport {property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nexport type SelectionSource = 'interaction'|'property';\nexport interface RequestSelectedDetail {\n  selected: boolean;\n  source: SelectionSource;\n}\n\nexport interface Layoutable {\n  layout: (updateItems?: boolean) => void;\n  debouncedLayout?: (updateItems?: boolean) => void | undefined;\n}\n\nexport type GraphicType = 'avatar'|'icon'|'medium'|'large'|'control'|null;\n\n/**\n * @fires request-selected {RequestSelectedDetail}\n * @fires list-item-rendered\n */\nexport class ListItemBase extends LitElement {\n  @query('slot') protected slotElement!: HTMLSlotElement|null;\n  @queryAsync('mwc-ripple') ripple!: Promise<Ripple|null>;\n\n  @property({type: String}) value = '';\n  @property({type: String, reflect: true}) group: string|null = null;\n  @property({type: Number, reflect: true}) tabindex = -1;\n  @property({type: Boolean, reflect: true})\n  @observer(function(this: ListItemBase, value: boolean) {\n    if (value) {\n      this.setAttribute('aria-disabled', 'true');\n    } else {\n      this.setAttribute('aria-disabled', 'false');\n    }\n  })\n  disabled = false;\n  @property({type: Boolean, reflect: true}) twoline = false;\n  @property({type: Boolean, reflect: true}) activated = false;\n  @property({type: String, reflect: true}) graphic: GraphicType = null;\n  @property({type: Boolean}) multipleGraphics = false;\n  @property({type: Boolean}) hasMeta = false;\n  @property({type: Boolean, reflect: true})\n  @observer(function(this: ListItemBase, value: boolean) {\n    if (value) {\n      this.removeAttribute('aria-checked');\n      this.removeAttribute('mwc-list-item');\n      this.selected = false;\n      this.activated = false;\n      this.tabIndex = -1;\n    } else {\n      this.setAttribute('mwc-list-item', '');\n    }\n  })\n  noninteractive = false;\n  @property({type: Boolean, reflect: true})\n  @observer(function(this: ListItemBase, value: boolean) {\n    const role = this.getAttribute('role');\n    const isAriaSelectable = role === 'gridcell' || role === 'option' ||\n        role === 'row' || role === 'tab';\n\n    if (isAriaSelectable && value) {\n      this.setAttribute('aria-selected', 'true');\n    } else if (isAriaSelectable) {\n      this.setAttribute('aria-selected', 'false');\n    }\n\n    if (this._firstChanged) {\n      this._firstChanged = false;\n      return;\n    }\n\n    if (this._skipPropRequest) {\n      return;\n    }\n\n    this.fireRequestSelected(value, 'property');\n  })\n  selected = false;\n\n  @state() protected shouldRenderRipple = false;\n  @state() _managingList: Layoutable|null = null;\n\n  protected boundOnClick = this.onClick.bind(this);\n  protected _firstChanged = true;\n  protected _skipPropRequest = false;\n  protected rippleHandlers: RippleHandlers = new RippleHandlers(() => {\n    this.shouldRenderRipple = true;\n    return this.ripple;\n  });\n  protected listeners: ({\n    target: Element;\n    eventNames: string[];\n    cb: EventListenerOrEventListenerObject;\n  })[] =\n      [\n        {\n          target: this,\n          eventNames: ['click'],\n          cb:\n              () => {\n                this.onClick();\n              },\n        },\n        {\n          target: this,\n          eventNames: ['mouseenter'],\n          cb: this.rippleHandlers.startHover,\n        },\n        {\n          target: this,\n          eventNames: ['mouseleave'],\n          cb: this.rippleHandlers.endHover,\n        },\n        {\n          target: this,\n          eventNames: ['focus'],\n          cb: this.rippleHandlers.startFocus,\n        },\n        {\n          target: this,\n          eventNames: ['blur'],\n          cb: this.rippleHandlers.endFocus,\n        },\n        {\n          target: this,\n          eventNames: ['mousedown', 'touchstart'],\n          cb:\n              (e: Event) => {\n                const name = e.type;\n                this.onDown(name === 'mousedown' ? 'mouseup' : 'touchend', e);\n              },\n        },\n      ];\n\n  get text() {\n    const textContent = this.textContent;\n\n    return textContent ? textContent.trim() : '';\n  }\n\n  override render() {\n    const text = this.renderText();\n    const graphic = this.graphic ? this.renderGraphic() : html``;\n    const meta = this.hasMeta ? this.renderMeta() : html``;\n\n    return html`\n      ${this.renderRipple()}\n      ${graphic}\n      ${text}\n      ${meta}`;\n  }\n\n  protected renderRipple() {\n    if (this.shouldRenderRipple) {\n      return html`\n      <mwc-ripple\n        .activated=${this.activated}>\n      </mwc-ripple>`;\n    } else if (this.activated) {\n      return html`<div class=\"fake-activated-ripple\"></div>`;\n    } else {\n      return '';\n    }\n  }\n\n  protected renderGraphic() {\n    const graphicClasses = {\n      multi: this.multipleGraphics,\n    };\n\n    return html`\n      <span class=\"mdc-deprecated-list-item__graphic material-icons ${\n        classMap(graphicClasses)}\">\n        <slot name=\"graphic\"></slot>\n      </span>`;\n  }\n\n  protected renderMeta() {\n    return html`\n      <span class=\"mdc-deprecated-list-item__meta material-icons\">\n        <slot name=\"meta\"></slot>\n      </span>`;\n  }\n\n  protected renderText() {\n    const inner = this.twoline ? this.renderTwoline() : this.renderSingleLine();\n    return html`\n      <span class=\"mdc-deprecated-list-item__text\">\n        ${inner}\n      </span>`;\n  }\n\n  protected renderSingleLine() {\n    return html`<slot></slot>`;\n  }\n\n  protected renderTwoline() {\n    return html`\n      <span class=\"mdc-deprecated-list-item__primary-text\">\n        <slot></slot>\n      </span>\n      <span class=\"mdc-deprecated-list-item__secondary-text\">\n        <slot name=\"secondary\"></slot>\n      </span>\n    `;\n  }\n\n  protected onClick() {\n    this.fireRequestSelected(!this.selected, 'interaction');\n  }\n\n  protected onDown(upName: string, evt: Event) {\n    const onUp = () => {\n      window.removeEventListener(upName, onUp);\n      this.rippleHandlers.endPress();\n    };\n\n    window.addEventListener(upName, onUp);\n    this.rippleHandlers.startPress(evt);\n  }\n\n  protected fireRequestSelected(selected: boolean, source: SelectionSource) {\n    if (this.noninteractive) {\n      return;\n    }\n\n    const customEv = new CustomEvent<RequestSelectedDetail>(\n        'request-selected',\n        {bubbles: true, composed: true, detail: {source, selected}});\n\n    this.dispatchEvent(customEv);\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n\n    if (!this.noninteractive) {\n      this.setAttribute('mwc-list-item', '');\n    }\n\n    for (const listener of this.listeners) {\n      for (const eventName of listener.eventNames) {\n        listener.target.addEventListener(\n            eventName, listener.cb, {passive: true});\n      }\n    }\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n\n    for (const listener of this.listeners) {\n      for (const eventName of listener.eventNames) {\n        listener.target.removeEventListener(eventName, listener.cb);\n      }\n    }\n\n    if (this._managingList) {\n      this._managingList.debouncedLayout ?\n          this._managingList.debouncedLayout(true) :\n          this._managingList.layout(true);\n    }\n  }\n\n  // composed flag, event fire through shadow root and up through composed tree\n  protected override firstUpdated() {\n    const ev = new Event('list-item-rendered', {bubbles: true, composed: true});\n    this.dispatchEvent(ev);\n  }\n}\n","import { Button } from \"@material/mwc-button\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\nimport { styles } from \"@material/mwc-button/styles.css\";\n\n@customElement(\"ha-button\")\nexport class HaButton extends Button {\n  static override styles = [\n    styles,\n    css`\n      ::slotted([slot=\"icon\"]) {\n        margin-inline-start: 0px;\n        margin-inline-end: 8px;\n        direction: var(--direction);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button\": HaButton;\n  }\n}\n","import { mdiGestureTap, mdiPalette } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { css, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport {\n  any,\n  array,\n  assert,\n  assign,\n  boolean,\n  object,\n  optional,\n  string,\n} from \"superstruct\";\nimport { fireEvent, HASSDomEvent } from \"../../../../common/dom/fire_event\";\nimport { entityId } from \"../../../../common/structs/is-entity-id\";\nimport { LocalizeFunc } from \"../../../../common/translations/localize\";\nimport \"../../../../components/ha-form/ha-form\";\nimport type { SchemaUnion } from \"../../../../components/ha-form/types\";\nimport type { HomeAssistant } from \"../../../../types\";\nimport type { TileCardConfig } from \"../../cards/types\";\nimport {\n  LovelaceTileFeatureConfig,\n  LovelaceTileFeatureContext,\n} from \"../../tile-features/types\";\nimport type { LovelaceCardEditor } from \"../../types\";\nimport \"../hui-sub-element-editor\";\nimport { actionConfigStruct } from \"../structs/action-struct\";\nimport { baseLovelaceCardConfig } from \"../structs/base-card-struct\";\nimport { EditSubElementEvent, SubElementEditorConfig } from \"../types\";\nimport { configElementStyle } from \"./config-elements-style\";\nimport \"./hui-tile-card-features-editor\";\n\nconst cardConfigStruct = assign(\n  baseLovelaceCardConfig,\n  object({\n    entity: optional(entityId()),\n    name: optional(string()),\n    icon: optional(string()),\n    color: optional(string()),\n    show_entity_picture: optional(boolean()),\n    vertical: optional(boolean()),\n    tap_action: optional(actionConfigStruct),\n    icon_tap_action: optional(actionConfigStruct),\n    features: optional(array(any())),\n  })\n);\n\n@customElement(\"hui-tile-card-editor\")\nexport class HuiTileCardEditor\n  extends LitElement\n  implements LovelaceCardEditor\n{\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _config?: TileCardConfig;\n\n  @state() private _subElementEditorConfig?: SubElementEditorConfig;\n\n  public setConfig(config: TileCardConfig): void {\n    assert(config, cardConfigStruct);\n    this._config = config;\n  }\n\n  private _schema = memoizeOne(\n    (localize: LocalizeFunc) =>\n      [\n        { name: \"entity\", selector: { entity: {} } },\n        {\n          name: \"\",\n          type: \"expandable\",\n          iconPath: mdiPalette,\n          title: localize(`ui.panel.lovelace.editor.card.tile.appearance`),\n          schema: [\n            {\n              name: \"\",\n              type: \"grid\",\n              schema: [\n                { name: \"name\", selector: { text: {} } },\n                {\n                  name: \"icon\",\n                  selector: {\n                    icon: {},\n                  },\n                  context: { icon_entity: \"entity\" },\n                },\n                {\n                  name: \"color\",\n                  selector: {\n                    \"ui-color\": {},\n                  },\n                },\n                {\n                  name: \"show_entity_picture\",\n                  selector: {\n                    boolean: {},\n                  },\n                },\n                {\n                  name: \"vertical\",\n                  selector: {\n                    boolean: {},\n                  },\n                },\n              ] as const,\n            },\n          ] as const,\n        },\n        {\n          name: \"\",\n          type: \"expandable\",\n          title: localize(`ui.panel.lovelace.editor.card.tile.actions`),\n          iconPath: mdiGestureTap,\n          schema: [\n            {\n              name: \"tap_action\",\n              selector: {\n                \"ui-action\": {},\n              },\n            },\n            {\n              name: \"icon_tap_action\",\n              selector: {\n                \"ui-action\": {},\n              },\n            },\n          ] as const,\n        },\n      ] as const\n  );\n\n  private _context = memoizeOne(\n    (entity_id?: string): LovelaceTileFeatureContext => ({ entity_id })\n  );\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    const stateObj = this.hass.states[this._config.entity ?? \"\"] as\n      | HassEntity\n      | undefined;\n\n    const schema = this._schema(this.hass!.localize);\n\n    if (this._subElementEditorConfig) {\n      return html`\n        <hui-sub-element-editor\n          .hass=${this.hass}\n          .config=${this._subElementEditorConfig}\n          .context=${this._context(this._config.entity)}\n          @go-back=${this._goBack}\n          @config-changed=${this.subElementChanged}\n        >\n        </hui-sub-element-editor>\n      `;\n    }\n\n    return html`\n      <ha-form\n        .hass=${this.hass}\n        .data=${this._config}\n        .schema=${schema}\n        .computeLabel=${this._computeLabelCallback}\n        @value-changed=${this._valueChanged}\n      ></ha-form>\n      <hui-tile-card-features-editor\n        .hass=${this.hass}\n        .stateObj=${stateObj}\n        .features=${this._config!.features ?? []}\n        @features-changed=${this._featuresChanged}\n        @edit-detail-element=${this._editDetailElement}\n      ></hui-tile-card-features-editor>\n    `;\n  }\n\n  private _valueChanged(ev: CustomEvent): void {\n    ev.stopPropagation();\n    if (!this._config || !this.hass) {\n      return;\n    }\n\n    const config: TileCardConfig = {\n      features: this._config.features,\n      ...ev.detail.value,\n    };\n    fireEvent(this, \"config-changed\", { config });\n  }\n\n  private _featuresChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    if (!this._config || !this.hass) {\n      return;\n    }\n\n    const features = ev.detail.features as LovelaceTileFeatureConfig[];\n    const config: TileCardConfig = {\n      ...this._config,\n      features,\n    };\n\n    if (features.length === 0) {\n      delete config.features;\n    }\n\n    fireEvent(this, \"config-changed\", { config });\n  }\n\n  private subElementChanged(ev: CustomEvent): void {\n    ev.stopPropagation();\n    if (!this._config || !this.hass) {\n      return;\n    }\n\n    const value = ev.detail.config;\n\n    const newConfigFeatures = this._config!.features\n      ? [...this._config!.features]\n      : [];\n\n    if (!value) {\n      newConfigFeatures.splice(this._subElementEditorConfig!.index!, 1);\n      this._goBack();\n    } else {\n      newConfigFeatures[this._subElementEditorConfig!.index!] = value;\n    }\n\n    this._config = { ...this._config!, features: newConfigFeatures };\n\n    this._subElementEditorConfig = {\n      ...this._subElementEditorConfig!,\n      elementConfig: value,\n    };\n\n    fireEvent(this, \"config-changed\", { config: this._config });\n  }\n\n  private _editDetailElement(ev: HASSDomEvent<EditSubElementEvent>): void {\n    this._subElementEditorConfig = ev.detail.subElementConfig;\n  }\n\n  private _goBack(): void {\n    this._subElementEditorConfig = undefined;\n  }\n\n  private _computeLabelCallback = (\n    schema: SchemaUnion<ReturnType<typeof this._schema>>\n  ) => {\n    switch (schema.name) {\n      case \"color\":\n      case \"icon_tap_action\":\n      case \"show_entity_picture\":\n      case \"vertical\":\n        return this.hass!.localize(\n          `ui.panel.lovelace.editor.card.tile.${schema.name}`\n        );\n\n      default:\n        return this.hass!.localize(\n          `ui.panel.lovelace.editor.card.generic.${schema.name}`\n        );\n    }\n  };\n\n  static get styles() {\n    return [\n      configElementStyle,\n      css`\n        .container {\n          display: flex;\n          flex-direction: column;\n        }\n        ha-form {\n          display: block;\n          margin-bottom: 24px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-tile-card-editor\": HuiTileCardEditor;\n  }\n}\n","import { mdiDelete, mdiDrag, mdiListBox, mdiPencil, mdiPlus } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { repeat } from \"lit/directives/repeat\";\nimport type { SortableEvent } from \"sortablejs\";\nimport { fireEvent } from \"../../../../common/dom/fire_event\";\nimport { stopPropagation } from \"../../../../common/dom/stop_propagation\";\nimport \"../../../../components/entity/ha-entity-picker\";\nimport \"../../../../components/ha-button\";\nimport \"../../../../components/ha-icon-button\";\nimport \"../../../../components/ha-list-item\";\nimport \"../../../../components/ha-svg-icon\";\nimport {\n  CustomTileFeatureEntry,\n  customTileFeatures,\n  CUSTOM_TYPE_PREFIX,\n  isCustomType,\n  stripCustomPrefix,\n} from \"../../../../data/lovelace_custom_cards\";\nimport { sortableStyles } from \"../../../../resources/ha-sortable-style\";\nimport {\n  loadSortable,\n  SortableInstance,\n} from \"../../../../resources/sortable.ondemand\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { getTileFeatureElementClass } from \"../../create-element/create-tile-feature-element\";\nimport { supportsCoverOpenCloseTileFeature } from \"../../tile-features/hui-cover-open-close-tile-feature\";\nimport { supportsCoverTiltTileFeature } from \"../../tile-features/hui-cover-tilt-tile-feature\";\nimport { supportsLightBrightnessTileFeature } from \"../../tile-features/hui-light-brightness-tile-feature\";\nimport { supportsVacuumCommandTileFeature } from \"../../tile-features/hui-vacuum-commands-tile-feature\";\nimport { LovelaceTileFeatureConfig } from \"../../tile-features/types\";\n\ntype FeatureType = LovelaceTileFeatureConfig[\"type\"];\ntype SupportsFeature = (stateObj: HassEntity) => boolean;\n\nconst FEATURE_TYPES: FeatureType[] = [\n  \"cover-open-close\",\n  \"cover-tilt\",\n  \"light-brightness\",\n  \"vacuum-commands\",\n];\n\nconst EDITABLES_FEATURE_TYPES = new Set<FeatureType>([\"vacuum-commands\"]);\n\nconst SUPPORTS_FEATURE_TYPES: Record<FeatureType, SupportsFeature | undefined> =\n  {\n    \"cover-open-close\": supportsCoverOpenCloseTileFeature,\n    \"cover-tilt\": supportsCoverTiltTileFeature,\n    \"light-brightness\": supportsLightBrightnessTileFeature,\n    \"vacuum-commands\": supportsVacuumCommandTileFeature,\n  };\n\nconst CUSTOM_FEATURE_ENTRIES: Record<\n  string,\n  CustomTileFeatureEntry | undefined\n> = {};\ncustomTileFeatures.forEach((feature) => {\n  CUSTOM_FEATURE_ENTRIES[feature.type] = feature;\n});\n\ndeclare global {\n  interface HASSDomEvents {\n    \"features-changed\": {\n      features: LovelaceTileFeatureConfig[];\n    };\n  }\n}\n\n@customElement(\"hui-tile-card-features-editor\")\nexport class HuiTileCardFeaturesEditor extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: HassEntity;\n\n  @property({ attribute: false })\n  public features?: LovelaceTileFeatureConfig[];\n\n  @property() public label?: string;\n\n  private _featuresKeys = new WeakMap<LovelaceTileFeatureConfig, string>();\n\n  private _sortable?: SortableInstance;\n\n  public disconnectedCallback() {\n    this._destroySortable();\n  }\n\n  private _supportsFeatureType(type: string): boolean {\n    if (!this.stateObj) return false;\n\n    if (isCustomType(type)) {\n      const customType = stripCustomPrefix(type);\n      const customFeatureEntry = CUSTOM_FEATURE_ENTRIES[customType];\n      if (!customFeatureEntry?.supported) return true;\n      try {\n        return customFeatureEntry.supported(this.stateObj);\n      } catch {\n        return false;\n      }\n    }\n\n    const supportsFeature = SUPPORTS_FEATURE_TYPES[type];\n    return !supportsFeature || supportsFeature(this.stateObj);\n  }\n\n  private _isFeatureTypeEditable(type: string) {\n    if (isCustomType(type)) {\n      const customType = stripCustomPrefix(type);\n      const customFeatureEntry = CUSTOM_FEATURE_ENTRIES[customType];\n      return customFeatureEntry?.configurable;\n    }\n\n    return EDITABLES_FEATURE_TYPES.has(type as FeatureType);\n  }\n\n  private _getFeatureTypeLabel(type: string) {\n    if (isCustomType(type)) {\n      const customType = stripCustomPrefix(type);\n      const customFeatureEntry = CUSTOM_FEATURE_ENTRIES[customType];\n      return customFeatureEntry?.name || type;\n    }\n    return this.hass!.localize(\n      `ui.panel.lovelace.editor.card.tile.features.types.${type}.label`\n    );\n  }\n\n  private _getKey(feature: LovelaceTileFeatureConfig) {\n    if (!this._featuresKeys.has(feature)) {\n      this._featuresKeys.set(feature, Math.random().toString());\n    }\n\n    return this._featuresKeys.get(feature)!;\n  }\n\n  protected firstUpdated() {\n    this._createSortable();\n  }\n\n  private _getSupportedFeaturesType() {\n    const featuresTypes = FEATURE_TYPES as string[];\n    const customFeaturesTypes = customTileFeatures.map(\n      (feature) => `${CUSTOM_TYPE_PREFIX}${feature.type}`\n    );\n    return featuresTypes\n      .concat(customFeaturesTypes)\n      .filter((type) => this._supportsFeatureType(type));\n  }\n\n  protected render(): TemplateResult | null {\n    if (!this.features || !this.hass) {\n      return null;\n    }\n\n    const supportedFeaturesType = this._getSupportedFeaturesType();\n\n    const types = supportedFeaturesType.filter((type) => !isCustomType(type));\n    const customTypes = supportedFeaturesType.filter((type) =>\n      isCustomType(type)\n    );\n\n    return html`\n      <ha-expansion-panel outlined>\n        <h3 slot=\"header\">\n          <ha-svg-icon .path=${mdiListBox}></ha-svg-icon>\n          ${this.hass!.localize(\n            \"ui.panel.lovelace.editor.card.tile.features.name\"\n          )}\n        </h3>\n        <div class=\"content\">\n          ${supportedFeaturesType.length === 0 && this.features.length === 0\n            ? html`\n                <ha-alert type=\"info\">\n                  ${this.hass!.localize(\n                    \"ui.panel.lovelace.editor.card.tile.features.no_compatible_available\"\n                  )}\n                </ha-alert>\n              `\n            : null}\n          <div class=\"features\">\n            ${repeat(\n              this.features,\n              (featureConf) => this._getKey(featureConf),\n              (featureConf, index) => {\n                const type = featureConf.type;\n                const supported = this._supportsFeatureType(type);\n                const editable = this._isFeatureTypeEditable(type);\n                return html`\n                  <div class=\"feature\">\n                    <div class=\"handle\">\n                      <ha-svg-icon .path=${mdiDrag}></ha-svg-icon>\n                    </div>\n                    <div class=\"feature-content\">\n                      <div>\n                        <span> ${this._getFeatureTypeLabel(type)} </span>\n                        ${this.stateObj && !supported\n                          ? html`\n                              <span class=\"secondary\">\n                                ${this.hass!.localize(\n                                  \"ui.panel.lovelace.editor.card.tile.features.not_compatible\"\n                                )}\n                              </span>\n                            `\n                          : null}\n                      </div>\n                    </div>\n                    ${editable\n                      ? html`\n                          <ha-icon-button\n                            .label=${this.hass!.localize(\n                              `ui.panel.lovelace.editor.card.tile.features.edit`\n                            )}\n                            .path=${mdiPencil}\n                            class=\"edit-icon\"\n                            .index=${index}\n                            @click=${this._editFeature}\n                            .disabled=${!supported}\n                          ></ha-icon-button>\n                        `\n                      : null}\n                    <ha-icon-button\n                      .label=${this.hass!.localize(\n                        `ui.panel.lovelace.editor.card.tile.features.remove`\n                      )}\n                      .path=${mdiDelete}\n                      class=\"remove-icon\"\n                      .index=${index}\n                      @click=${this._removeFeature}\n                    ></ha-icon-button>\n                  </div>\n                `;\n              }\n            )}\n          </div>\n          ${supportedFeaturesType.length > 0\n            ? html`\n                <ha-button-menu\n                  fixed\n                  @action=${this._addFeature}\n                  @closed=${stopPropagation}\n                >\n                  <ha-button\n                    slot=\"trigger\"\n                    outlined\n                    .label=${this.hass!.localize(\n                      `ui.panel.lovelace.editor.card.tile.features.add`\n                    )}\n                  >\n                    <ha-svg-icon .path=${mdiPlus} slot=\"icon\"></ha-svg-icon>\n                  </ha-button>\n                  ${types.map(\n                    (type) => html`\n                      <ha-list-item .value=${type}>\n                        ${this._getFeatureTypeLabel(type)}\n                      </ha-list-item>\n                    `\n                  )}\n                  ${types.length > 0 && customTypes.length > 0\n                    ? html`<li divider role=\"separator\"></li>`\n                    : null}\n                  ${customTypes.map(\n                    (type) => html`\n                      <ha-list-item .value=${type}>\n                        ${this._getFeatureTypeLabel(type)}\n                      </ha-list-item>\n                    `\n                  )}\n                </ha-button-menu>\n              `\n            : null}\n        </div>\n      </ha-expansion-panel>\n    `;\n  }\n\n  private async _createSortable() {\n    const Sortable = await loadSortable();\n    this._sortable = new Sortable(\n      this.shadowRoot!.querySelector(\".features\")!,\n      {\n        animation: 150,\n        fallbackClass: \"sortable-fallback\",\n        handle: \".handle\",\n        onChoose: (evt: SortableEvent) => {\n          (evt.item as any).placeholder =\n            document.createComment(\"sort-placeholder\");\n          evt.item.after((evt.item as any).placeholder);\n        },\n        onEnd: (evt: SortableEvent) => {\n          // put back in original location\n          if ((evt.item as any).placeholder) {\n            (evt.item as any).placeholder.replaceWith(evt.item);\n            delete (evt.item as any).placeholder;\n          }\n          this._rowMoved(evt);\n        },\n      }\n    );\n  }\n\n  private _destroySortable() {\n    this._sortable?.destroy();\n    this._sortable = undefined;\n  }\n\n  private async _addFeature(ev: CustomEvent): Promise<void> {\n    const index = ev.detail.index as number;\n\n    if (index == null) return;\n\n    const value = this._getSupportedFeaturesType()[index];\n    if (!value) return;\n\n    const elClass = await getTileFeatureElementClass(value);\n\n    let newFeature: LovelaceTileFeatureConfig;\n    if (elClass && elClass.getStubConfig) {\n      newFeature = await elClass.getStubConfig(this.hass!, this.stateObj);\n    } else {\n      newFeature = { type: value } as LovelaceTileFeatureConfig;\n    }\n    const newConfigFeature = this.features!.concat(newFeature);\n    fireEvent(this, \"features-changed\", { features: newConfigFeature });\n  }\n\n  private _rowMoved(ev: SortableEvent): void {\n    if (ev.oldIndex === ev.newIndex) {\n      return;\n    }\n\n    const newFeatures = this.features!.concat();\n\n    newFeatures.splice(ev.newIndex!, 0, newFeatures.splice(ev.oldIndex!, 1)[0]);\n\n    fireEvent(this, \"features-changed\", { features: newFeatures });\n  }\n\n  private _removeFeature(ev: CustomEvent): void {\n    const index = (ev.currentTarget as any).index;\n    const newfeatures = this.features!.concat();\n\n    newfeatures.splice(index, 1);\n\n    fireEvent(this, \"features-changed\", { features: newfeatures });\n  }\n\n  private _editFeature(ev: CustomEvent): void {\n    const index = (ev.currentTarget as any).index;\n    fireEvent(this, \"edit-detail-element\", {\n      subElementConfig: {\n        index,\n        type: \"tile-feature\",\n        elementConfig: this.features![index],\n      },\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      sortableStyles,\n      css`\n        :host {\n          display: flex !important;\n          flex-direction: column;\n        }\n        .content {\n          padding: 12px;\n        }\n        ha-expansion-panel {\n          display: block;\n          --expansion-panel-content-padding: 0;\n          border-radius: 6px;\n        }\n        h3 {\n          margin: 0;\n          font-size: inherit;\n          font-weight: inherit;\n        }\n        ha-svg-icon,\n        ha-icon {\n          color: var(--secondary-text-color);\n        }\n        ha-button-menu {\n          margin-top: 8px;\n        }\n        .feature {\n          display: flex;\n          align-items: center;\n        }\n        .feature .handle {\n          padding-right: 8px;\n          cursor: move;\n          padding-inline-end: 8px;\n          padding-inline-start: initial;\n          direction: var(--direction);\n        }\n        .feature .handle > * {\n          pointer-events: none;\n        }\n\n        .feature-content {\n          height: 60px;\n          font-size: 16px;\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n          flex-grow: 1;\n        }\n\n        .feature-content div {\n          display: flex;\n          flex-direction: column;\n        }\n\n        .remove-icon,\n        .edit-icon {\n          --mdc-icon-button-size: 36px;\n          color: var(--secondary-text-color);\n        }\n\n        .secondary {\n          font-size: 12px;\n          color: var(--secondary-text-color);\n        }\n\n        li[divider] {\n          border-bottom-color: var(--divider-color);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-tile-card-features-editor\": HuiTileCardFeaturesEditor;\n  }\n}\n"],"names":[],"sourceRoot":""}