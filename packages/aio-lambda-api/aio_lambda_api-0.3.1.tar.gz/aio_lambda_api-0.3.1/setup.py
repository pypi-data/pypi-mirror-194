# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['aio_lambda_api', 'aio_lambda_api._backends']

package_data = \
{'': ['*']}

install_requires = \
['jhalog']

extras_require = \
{'all': ['aioboto3', 'aiohttp[speedups]>3.8', 'orjson', 'pydantic', 'uvloop'],
 'aws': ['aioboto3'],
 'speedups': ['aiohttp[speedups]>3.8', 'orjson', 'uvloop'],
 'validation': ['pydantic']}

setup_kwargs = {
    'name': 'aio-lambda-api',
    'version': '0.3.1',
    'description': 'Simple AsyncIO AWS lambda HTTP API',
    'long_description': '![Tests](https://github.com/JGoutin/aio_lambda_api/workflows/tests/badge.svg)\n[![codecov](https://codecov.io/gh/JGoutin/aio_lambda_api/branch/main/graph/badge.svg)](https://codecov.io/gh/JGoutin/aio_lambda_api)\n[![PyPI](https://img.shields.io/pypi/v/aio_lambda_api.svg)](https://pypi.org/project/aio_lambda_api)\n\nA lightweight AsyncIO HTTP API for serverless functions like AWS lambda.\n\nFeatures:\n* Asyncio in AWS lambda.\n* FastAPI inspired routing, parameters and exception handling.\n* Detailed JSON formatted access log.\n* X-Request-ID header support (Including in logs).\n* Configurable request timeout.\n* Optional input validation using Pydantic.\n* Optional JSON serialization/deserialization speedup with Orjson.\n* Optional speedups using accelerated libraries (Like UVloop and ORJson).\n\nSupported backends:\n* AWS Lambda \n  * Request/responses are in API Gateway format (Only the format is required, \n    but can be triggered without using the API Gateway service).\n  * Support batches or requests with AWS SQS queue, AWS SNS or AWS MQ.\n  * JSON access logs works well with AWS Cloudwatch Insight.\n\nNot supported yet:\n* Routes with variables (Like `"/items/{item_id}"`).\n* Query strings.\n* Pydantic models as response or request body.\n* More backends.\n* AWS Lambda backend: AWS SSM parameter store helper.\n\n## Usage\n\n### Usage with AWS lambda\n\nFunction code example (`app.py`):\n```python\nfrom aio_lambda_api import Handler\n\nhandler = Handler()\n\n@handler.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\nAWS lambda function handler must be configured to `app.handler`.\n\n### Routing\n\nThe `aio_lambda_api.Handler` class provides decorators to configure routes for each \nHTTP method:\n* `Handler.get()`: GET.\n* `Handler.head()`: HEAD.\n* `Handler.post()`: POST.\n* `Handler.put()`: PUT.\n* `Handler.patch()`: PATCH.\n* `Handler.delete()`: DELETE.\n* `Handler.options()`: OPTIONS.\n\nFor all decorators, the first arguments is the HTTP path and is required.\n\nThe decorated function is executed when the defined HTTP path and method matches.\n\nBy default, the body of the request is parsed as JSON and injected in the function as \narguments.\nIf Pydantic is installed, parameters are validated against arguments types annotations.\n\nThe decorated function must return a JSON serializable object or `None`. If the function\nreturns `None`, the returned status code is automatically set to `204`.\n\n### Exception handling\n\nIt is possible to trigger a response using the `aio_lambda_api.HTTPException` as follow:\n\n```python\nfrom aio_lambda_api import Handler, HTTPException\n\nhandler = Handler()\n\nitems = {"foo": "The Foo Wrestlers"}\n\n@handler.get("/item")\nasync def read_item(item_id: str):\n    if item_id not in items:\n        raise HTTPException(status_code=404, detail="Item not found")\n    return {"item": items[item_id]}\n```\n\nIf an exception is risen in routes functions, the behavior is the following:\n* `aio_lambda_api.HTTPException`: Converted to HTTP response with the \n  specified body and returns code.\n* `pydantic.ValidationError`: Converted to 422 HTTP error response with Pydantic error \n  details as body.\n* Other exceptions: Reraised. Callers using the Lambda API will\n  be able to analyse the error like any other Python lambda error \n  (With `errorType`, `errorMessage` and `stackTrace`)\n  Callers using an HTTP endpoint/API gateway will receive a simple 500 error with no\n  details.\n\n### Customizing responses\n\n#### Return code\n\nIt is possible to select the return code (when no exception occurs) using the\n`status_code` argument. If not specified `200` is used.\n\n```python\nfrom aio_lambda_api import Handler\n\nhandler = Handler()\n\n@handler.get("/", status_code=201)\ndef read_root():\n    return {"Hello": "World"}\n```\n\n#### Headers\n\nIt is possible to configure headers by using the `Response` object from arguments:\n\n```python\nfrom aio_lambda_api import Handler, Response\n\nhandler = Handler()\n\n@handler.get("/")\nasync def read_item(response: Response):\n    response.headers["Cache-Control"] = "no-cache"\n\n    return {"Hello": "World"}\n```\n\n#### Custom response\n\nIt is possible to fully configure the response by returning the `Response` object.\n\n```python\nfrom aio_lambda_api import Handler, Response\n\nhandler = Handler()\n\n@handler.get("/")\nasync def read_item():\n    return Response(\n      status_code=202,\n      media_type="application/octet-stream",\n      content=b"helloworld"\n    )\n```\n\nThe default `Response` class accept `str` or `bytes` as content.\n\nThe `JSONResponse` object is also available, it is the default response object when not \nexplicitly set.\n\nIt is possible to create a subclass of `Response` class to have a custom behavior. The\n`Response.render` method is responsible for the serialization of the response.\n\nNote: If a response class returns a `bytes` content after `Response.render`, this\ncontent will be base64 encoded automatically in the API Gateway compatible response\nreturned.\n\n### Accessing Request data\n\nIt is possible to access request data by using the `Request` object from arguments:\n\n```python\nfrom aio_lambda_api import Handler, Request\n\nhandler = Handler()\n\n@handler.get("/")\nasync def read_item(request: Request):\n    user_agent = request.headers["user-agent"]\n    return {"Hello": user_agent}\n```\n\nNote: All headers keys are lowercase in the `Request` object.\n\n### Logging\n\nAn access log is automatically generated using the \n[Jhalog-Python](https://github.com/JGoutin/jhalog-python) library.\n\nAll request and all exceptions from routes functions are logged in the access log \n(Including reraised 500 errors.)\n\nWhen raising `aio_lambda_api.HTTPException`, it is possible to add extra information\nto the logs using the `error_detail` arguments (This will be shown in logs but will not\nbe visible by the client in the response).\n\nThe logger dict can be accessed from any routes functions using the\n`aio_lambda_api.get_logger` function. This can be used to add custom logs entries. All\nlog entries must be JSON serializable.\n\nDefaults log fields:\n* `error_detail`: `error_detail` argument value of `aio_lambda_api.HTTPException`.\n* `execution_time`: Execution time in ms of the route function.\n* `level`: Logging level (`info`, `warning`, `error`, `critical`).\n* `method`: HTTP method of the request.\n* `path`: HTTP path of the request.\n* `id`: `X-Request-Id` header is present.\n* `server_id`: Server running the function.\n* `status_code`: HTTP status code of the response.\n\n### Async initialization\n\nIn AWS lambda the asyncio context is limited to the routes functions.\n\nBut, the `aio_lambda_api.Handler` class provides methods to run async function outside \nroutes functions:\n* `Handler.run_async`: Runs an async function and returns the result.\n* `Handler.enter_async_context`: Initialize an async contextmanager and returns the\n  initialized object. The Context manager is also attached to the \n `aio_lambda_api.Handler` exit stack (And will be exited with the handler; note that \n  there is no guarantee that this is executed with AWS lambda).\n\n```python\nfrom aio_lambda_api import Handler\nfrom database import Database\n\nhandler = Handler()\n\n# Initialize a database connection outside routes functions\n# AWS lambda will keep this value cached between runs\n\nasync def init_database():\n  db = Database()\n  await db.connect()\n  return db\n\nDB = handler.run_async(init_database())\n\n# Variable can then be used normally from routes functions\n\n@handler.get("/user")\ndef get_fron_db():\n  return await DB.select("*")\n\n```\n\n### Configuration \n\n#### Settings\n\nThese settings are passed to the handle with environment variables.\n\n* `FUNCTION_TIMEOUT`: The route function call timeout in seconds. \n  Available as `aio_lambda_api.settings.FUNCTION_TIMEOUT`. Default to 30s.\n* `CONNECTION_TIMEOUT`: Global connection timeout in seconds.\n  Available as `aio_lambda_api.settings.CONNECTION_TIMEOUT`.\n  Also used in `aio_lambda_api.aws.BOTO_CLIENT_CONFIG`. Default to 5s.\n* `READ_TIMEOUT`: Global read timeout in seconds.\n  Available as `aio_lambda_api.settings.READ_TIMEOUT`.\n  Also used in `aio_lambda_api.aws.BOTO_CLIENT_CONFIG`. Default to 15s.\n* `BOTO_PARAMETER_VALIDATION`: If set enable `boto3` input validation in \n  `aio_lambda_api.aws.BOTO_CLIENT_CONFIG`. Disabled by default to improve \n  performance.\n* `BOTO_MAX_POOL_CONNECTIONS`: `boto3` `max_pool_connections` in \n  `aio_lambda_api.aws.BOTO_CLIENT_CONFIG`. Default to 100.\n\n#### AWS utilities\n\n##### Botocore default config.\n\nA `botocore.client.Config` is provided by \n`aio_lambda_api.backends.aws_lambda.Backend.botocore_config()` and can be used with\n`aioboto3` clients and resources.\n\n```python\nimport aioboto3\nfrom aio_lambda_api.backends.aws_lambda import Backend\n\nsession = aioboto3.Session()\nasync with session.resource("s3", config=Backend.botocore_config()) as s3:\n    pass\n```\n\nWhen using `aio_lambda_api.backends.aws_lambda.Backend.botocore_config()`, \nbotocore/aiobotocore is configured to use orjson is available to speed up JSON \nserialization/deserialization.\n\nIf the `speedups` extra is installed, aiohttp is installed with its own speedups extra.\nSince aiobotocore and aioboto3 rely on aiohttp, this will also improve their \nperformance.\n\n## Installation\n\n### Minimal installation:\n```bash\npip install aio-lambda-api\n```\n\n### Installations with extras:\n\nMultiple extra are provided\n\n```bash\npip install aio-lambda-api[all]\n```\n\n* `all`: Install all extras.\n* `aws`: Install AWS SDK (`aioboto3`).\n* `validation`: Install input validation dependencies (`pydantic`).\n* `speedups`: Input performance speedups dependencies (`uvloop`, `orjson`).\n',
    'author': 'JGoutin',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/JGoutin/aio_lambda_api',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
