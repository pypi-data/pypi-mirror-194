
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _loop_transform_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GetParentForOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.get_parent_for"

  _ODS_REGIONS = (0, True)

  def __init__(self, parent, target, *, num_loops=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    assert num_loops is not None, "attribute num_loops must be specified"
    attributes["num_loops"] = num_loops
    results.append(parent)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def num_loops(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num_loops"])

  @num_loops.setter
  def num_loops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_loops"] = value

  @builtins.property
  def parent(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopOutlineOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.outline"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, func_name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["func_name"] = func_name
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def func_name(self):
    return _ods_ir.StringAttr(self.operation.attributes["func_name"])

  @func_name.setter
  def func_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["func_name"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopPeelOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.peel"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, fail_if_already_divisible=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    assert fail_if_already_divisible is not None, "attribute fail_if_already_divisible must be specified"
    attributes["fail_if_already_divisible"] = fail_if_already_divisible
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def fail_if_already_divisible(self):
    return _ods_ir.BoolAttr(self.operation.attributes["fail_if_already_divisible"])

  @fail_if_already_divisible.setter
  def fail_if_already_divisible(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fail_if_already_divisible"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopPipelineOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.pipeline"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, iteration_interval=None, read_latency=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    assert iteration_interval is not None, "attribute iteration_interval must be specified"
    attributes["iteration_interval"] = iteration_interval
    assert read_latency is not None, "attribute read_latency must be specified"
    attributes["read_latency"] = read_latency
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def iteration_interval(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["iteration_interval"])

  @iteration_interval.setter
  def iteration_interval(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iteration_interval"] = value

  @builtins.property
  def read_latency(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["read_latency"])

  @read_latency.setter
  def read_latency(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["read_latency"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopUnrollOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.unroll"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, factor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["factor"] = factor
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def factor(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["factor"])

  @factor.setter
  def factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["factor"] = value
