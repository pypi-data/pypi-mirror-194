#!/usr/bin/env python
import json
from redis import StrictRedis
import math
import sys
from pathlib import Path
import codefast as cf
from typing import List, Tuple, Dict


def parse_traffic(data: dict, interface_name: str,
                  init_day: str) -> Dict[str, float]:
    '''
    :data: dict, json formated data generated by `vnstat --json d`,
    :interface_name: str, which interfact to parse
    :init_day: str, from which date the traffic is counted
    '''
    bit_shift: int = 20
    daykey: str = 'days'
    interface_key: str = 'id'
    if data['vnstatversion'].startswith('2.'):
        bit_shift = 30
        daykey = 'day'
        interface_key = 'name'

    # print(data, interface_name, init_day)
    js = next(
        filter(lambda e: e[interface_key] == interface_name,
               data['interfaces']), {})
    if not js:
        return {'tx': 0, 'rx': 0, 'total': 1, 'yesterday': 0}

    daily = js['traffic'][daykey]
    daily.sort(key=lambda d: int(d['date']['year']) * 10000 + int(d['date'][
        'month']) * 100 + int(d['date']['day']),
        reverse=True)

    _id = next((i for i, e in enumerate(daily)
                if int(e['date']['day']) == int(init_day)),
               len(daily) - 1)

    rx = sum(e['rx'] for e in daily[:_id + 1]) / (1 << bit_shift)
    tx = sum(e['tx'] for e in daily[:_id + 1]) / (1 << bit_shift)
    previous = (daily[0]['rx'] + daily[0]['tx']) / (1 << bit_shift)
    total = rx + tx
    return {'tx': tx, 'rx': rx, 'total': total, 'yesterday': previous}


class MachineStatus:
    def __init__(self,
                 raw_data: dict,
                 counter: int,
                 alive_window: int = 20) -> None:
        self.raw = raw_data
        self.name = self.raw['static']['name']
        self.bar = '❘'
        self._global_counter = counter
        self.alert_threshold = 0.8
        self.alive_windown = alive_window

    def get_status(self) -> str:
        this_counter = int(self.raw['counter'])
        if self._global_counter - this_counter > self.alive_windown:
            return cf.fp.red('DOWN')
        return cf.fp.green('RUNNING')

    def get_uptime(self) -> str:
        return self.raw['dynamic']['uptime']

    def get_ip(self) -> str:
        return self.raw['ip']['query']

    def get_location(self) -> str:
        _ip = self.raw['ip']
        return '/'.join([_ip['city'][:10], _ip['countryCode']])

    def get_cpu(self) -> str:
        cpu = float(self.raw.get('cpu', 0)) / 100
        return self._draw_bar(cpu) + '({:.1f}%)'.format(cpu * 100)

    def get_traffic(self) -> str:
        st = self.raw['static']
        quota = st['traffic_quota']
        init_day = st['init_day']
        quota_number = int(quota.replace('GB', ''))
        parsed = parse_traffic(self.raw['dynamic']['traffic'], st['interface'],
                               init_day)
        ratio = parsed['total'] / quota_number
        if self.name.lower() in ['olvps']:
            ratio = parsed['tx'] / quota_number
        if ratio >= 1:
            cf.warning('ratio {} is too large'.format(ratio))
        ratio = min(ratio, 1)
        extra_info = '({}%,{})'.format(int(100 * ratio), quota_number)
        bar_info = self._draw_bar(ratio)
        return bar_info + extra_info

    def _draw_bar(self, ratio: float) -> str:
        ceiled = math.ceil(ratio * 10)
        if ratio > self.alert_threshold:
            return cf.fp.red(self.bar * ceiled) + self.bar * (10 - ceiled)
        return cf.fp.green(self.bar * ceiled) + self.bar * (10 - ceiled)

    def get_disk(self) -> str:
        usage = self.raw['dynamic']['disk']
        ratio = usage['used'] / usage['total']
        bar_info = self._draw_bar(ratio)
        extra_info = '({}%,{:.1f})'.format(int(100 * ratio),
                                           usage['total'] / (1 << 30))
        return bar_info + extra_info

    def get_last_active(self) -> str:
        return self.raw['dynamic'].get('last_active', 'null')

    def display(self):
        status = self.get_status()
        if status == cf.fp.red('DOWN'):
            return
        name = self.name
        uptime = self.get_uptime()
        ip = self.get_ip()
        location = self.get_location()
        cpu = self.get_cpu()
        traffic = self.get_traffic()
        disk = self.get_disk()
        last_active = self.get_last_active()
        print('{:<17} {:<13} {:<8} {:<15} {:<13} {:<30} {:<30} {:<30} {:<20}'.
              format(status, name, uptime, ip, location, traffic, disk, cpu,
                     last_active))


class Context:
    def __init__(self) -> None:
        sys.path.insert(0, str(Path.home()) + '/.config')
        from redis_sg import REDIS_HOST, REDIS_PORT, REDIS_PASSWORD

        self._redis = StrictRedis(host=REDIS_HOST,
                                  port=REDIS_PORT,
                                  password=REDIS_PASSWORD)
        self._counter = 1
        self._dict = 'vpsstatus'

    def run(self):
        # self._redis.hset(self._dict, 'counter', 1)
        getall = self._redis.hgetall(self._dict)
        # print(getall)
        ctr = int(getall[b'counter'].decode())
        # self._redis.hdel(self._dict, 'virmatch')
        del getall[b'counter']
        print('{:<8} {:<13} {:<8} {:<15} {:<13} {:<30} {:<30} {:<21} {:<20}'.
              format('STATUS', 'NAME', 'UPTIME', 'IP', 'LOCATION',
                     cf.fp.cyan('TRAFFIC'), cf.fp.cyan('DISK'), 'CPU',
                     'LAST_ACTIVE'))

        for vs in getall.values():
            ms = MachineStatus(json.loads(vs.decode()), ctr, alive_window=200)
            ms.display()

        # self._redis.hdel(self._dict, 'OLVPS')


def entry():
    Context().run()
    print('')
