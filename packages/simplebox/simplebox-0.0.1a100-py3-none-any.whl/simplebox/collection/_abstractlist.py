#!/usr/bin/env python
# -*- coding:utf-8 -*-
from functools import reduce
from itertools import groupby, chain
from random import choice
from typing import Iterable, Callable, List, Dict, Any, Optional

from .._internal import _T, _R, _K, _V
from ..exceptions import raise_exception
from ..number import Integer


class _AbstractList(List[_T]):

    def __init__(self, *args: _T, iterable: Iterable[_T] = None):
        if args:
            super().__init__(args)
        elif iterable:
            super().__init__(iterable)
        else:
            super().__init__([])

    def maps(self, func: Callable[['_AbstractList[_T]', '_AbstractList[_R]'], None]) -> '_AbstractList[_R]':
        """
        func receives the entire ArrayList as a parameter and an empty ArrayList for processing results.
        Compared to map method, there is more room for manoeuvre
        """
        ret = _AbstractList()
        func(self, ret)
        return ret

    def map(self, func: Callable[[_T], _R]) -> '_AbstractList[_R]':
        """
        A stream of element type T is converted to a stream of element type R through a Function.
        """
        return _AbstractList(iterable=map(func, self))

    def flat_map(self, func: Callable[[_T], '_AbstractList[_R]'] = lambda x: x) -> '_AbstractList[_R]':
        """
        Flattening the flow, using a Function to convert each element in a stream with an element type T into
        a stream with an element type R, and then merging the converted streams.
        """
        return _AbstractList(iterable=chain.from_iterable(map(func, self)))

    def flat(self) -> '_AbstractList[_R]':
        """
        Flatten a multidimensional list into a one-dimensional array.
        Note that the method flattens all arrays. If controlled flattening is required, use the maps method.
        """

        def __press(iterable, ret: _AbstractList[_R]):
            if not issubclass(type(iterable), Iterable):
                ret.append(iterable)
            else:
                for i in iterable:
                    __press(i, ret)

        return self.maps(__press)

    def filter(self, func: Callable[[_T], bool]) -> '_AbstractList[_T]':
        """
        Filter the elements in the stream, retaining only those elements that meet the criteria specified by Predicate.
        """
        return _AbstractList(iterable=(element for element in self if func(element)))

    def filter_else_raise(self, func: Callable[[_T], bool],
                          exception: Callable[[_T], BaseException]) -> '_AbstractList[_T]':
        """
        Filter the elements in the stream, retaining only those elements that meet the criteria specified by Predicate.
        If the conditions are not met during filtering, an exception is thrown directly
        """
        return _AbstractList(
            iterable=(
                element if func(element) else (lambda element: raise_exception(exception(element))(element))(element)
                for
                element in self))

    def distinct(self, func: Callable[['_AbstractList[_T]'], _T] = None) -> '_AbstractList[_T]':
        """
        Filter to remove duplicate elements by hashCode() and equals of the elements generated by the stream
        If it is a custom object, you need to override __eq__ and __hash__
        """
        if isinstance(func, Callable):
            return _AbstractList(iterable=reduce(func, [_AbstractList(iterable=[])] + self))
        return _AbstractList(iterable=set(self))

    def limit(self, size: int) -> '_AbstractList[_T]':
        """
        Truncates the stream so that it contains only a specified number of elements at most.
        """
        if self.size().lte(size):
            return _AbstractList(iterable=self)
        else:
            return _AbstractList(iterable=self[:size])

    def skip(self, size: int) -> '_AbstractList[_T]':
        """
        Skipping elements, returning a stream with the first n elements thrown away, and returning an empty stream
        if there are less than n elements in the stream, complementary to limit(n).
        """
        if self.size().lte(size):
            return _AbstractList(iterable=[])
        else:
            return _AbstractList(iterable=self[size:])

    def sorted(self, key=None, reverse: bool = False) -> '_AbstractList[_T]':
        """
        Sort the stream.
        """
        return _AbstractList(iterable=sorted(self, key=key, reverse=reverse))

    def intersection(self, iterable: Iterable[_T],
                     distincter: Callable[['_AbstractList[_T]'], _T] = None) -> '_AbstractList[_T]':
        """
        Output intersection
        If it is a custom object, you need to override __eq__ and __hash__
        :param iterable: Iterate objects that take intersections.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """
        return _AbstractList(iterable=set(self.distinct(distincter)).intersection(
            set(_AbstractList(iterable=iterable).distinct(distincter))))

    def union(self, iterable: Iterable[_T], distincter: Callable[['_AbstractList[_T]'], _T] = None) -> '_AbstractList[_T]':
        """
        Output union
        If it is a custom object, you need to override __eq__ and __hash__
        :param iterable: Take the iteration object of the union.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """
        return _AbstractList(
            iterable=set(self.distinct(distincter)).union(set(_AbstractList(iterable=iterable).distinct(distincter))))

    def difference(self, iterable: Iterable[_T],
                   distincter: Callable[['_AbstractList[_T]'], _T] = None) -> '_AbstractList[_T]':
        """
        Output difference
        If it is a custom object, you need to override __eq__ and __hash__
        :param iterable: The subject of the comparison.  current list are present, but the iterable objects does not.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """
        return _AbstractList(
            iterable=set(self.distinct(distincter)).difference(
                set(_AbstractList(iterable=iterable).distinct(distincter))))

    def symmetric_difference(self, iterable: Iterable[_T],
                             distincter: Callable[['_AbstractList[_T]'], _T] = None) -> '_AbstractList[_T]':
        """
        The method returns a new list, the elements in the new list are the elements of
        the two lists that do not repeat, that is, the elements outside the intersection,
        and the elements in the new list will only exist in one of the lists.

        If it is a custom object, you need to override __eq__ and __hash__
        :param iterable: The subject of the comparison.  current list are present, but the iterable objects does not.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """
        return _AbstractList(
            iterable=set(self.distinct(distincter)).symmetric_difference(
                set(_AbstractList(iterable=iterable).distinct(distincter))))

    def take_while(self, predicate: Callable[[_T], bool]) -> '_AbstractList[_T]':
        """
        Elements that satisfy the specified predicate are retained from the beginning of
        the original stream until the first element that does not satisfy the Predicate is encountered.
        """
        tmp = []
        tmp_append = tmp.append
        for element in self:
            if predicate(element):
                tmp_append(element)
            else:
                break
        return _AbstractList(iterable=tmp)

    def drop_while(self, predicate: Callable[[_T], bool]) -> '_AbstractList[_T]':
        """
        Removes elements that satisfy the specified predicate from the beginning of
        the original stream until the first element that does not satisfy Predicate is encountered.
        """
        tmp = self[:]
        for i in range(self.size()):
            if predicate(self[i]):
                tmp.remove(self[i])
            else:
                break
        return tmp

    def partition(self, size: int) -> '_AbstractList[_AbstractList[_T]]':
        """
        Divide the list into multiple small lists according to the specified size, and form a two-dimensional list
        :param size: partition size, small list element number
        """
        if issubclass(type(size), int) and 0 < size < self.size():
            out = _AbstractList()
            for i in range(0, self.size() + 1, size):
                inner = self[i:i + size]
                if inner:
                    out.append(_AbstractList(iterable=inner))
            return out
        return _AbstractList(iterable=self)

    def for_each(self, func: Callable[[_T], None]) -> None:
        """
        Traversal, custom actions
        """
        for i in self:
            func(i)

    def isdisjoint(self, iterable: Iterable[_T], distincter: Callable[['_AbstractList[_T]'], _T] = None) -> bool:
        """
        Determine whether the intersection of the current list and iterable is an empty set
        :param iterable: Pending iteration objects.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """
        return set(self.distinct(distincter)).isdisjoint(set(_AbstractList(iterable=iterable).distinct(distincter)))

    def issubset(self, iterable: Iterable[_T], distincter: Callable[['_AbstractList[_T]'], _T] = None) -> bool:
        """
        Determine whether the current list contains iterable
        :param iterable: Pending iteration objects.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """
        return set(self.distinct(distincter)).issubset(set(_AbstractList(iterable=iterable).distinct(distincter)))

    def issuperset(self, iterable: Iterable[_T], distincter: Callable[['_AbstractList[_T]'], _T] = None) -> bool:
        """
        Determine whether the current list contains iterable
        :param iterable: Pending iteration objects.
        :param distincter: Deduplication algorithm, if None, use built-in set function.
        """

    def all_match(self, func: Callable[[_T], bool]) -> bool:
        """
        Check that all elements match
        """
        return all(map(func, self))

    def any_match(self, func: Callable[[_T], bool]) -> bool:
        """
        Check that at least one element matches
        """
        return any(map(func, self))

    def none_match(self, func: Callable[[_T], bool]) -> bool:
        """
        Check that not all elements are matched
        :param func:
        :return:
        """
        return not self.any_match(func)

    def find_first(self) -> Optional[_T]:
        """
        Returns the first element
        """
        if self.size().gt(0):
            return self[0]
        return None

    def find_any(self) -> Optional[_T]:
        """
        Returns any element in the current stream
        """
        if self.size().gt(0):
            return choice(self)
        return None

    def reduce(self, func: Callable[[_T, _T], _T], initial: _T = None) -> Optional[_T]:
        if initial is not None:
            return reduce(func, self, initial)
        else:
            try:
                return reduce(func, self)
            except TypeError:
                return None

    def count(self, obj: Any = None) -> Integer:
        """
        Returns the total number of elements in the stream
        :param obj: Elements with statistics, if None counts all
        """
        if obj:
            return Integer(super().count(obj))
        return self.size()

    def sum(self) -> int or float:
        """
        Sum the elements of the list
        """
        return sum(self)

    def max(self, key: Callable[[_T], Any] = lambda x: x, default: _T = None) -> Optional[_T]:
        """
        Returns the maximum value in the stream
        """
        return max(self, key=key, default=default)

    def min(self, key: Callable[[_T], Any] = lambda x: x, default: _T = None) -> Optional[_T]:
        """
        Returns the smallest value in the stream
        """
        return min(self, key=key, default=default)

    def group(self, func: Callable) -> Dict[_K, '_AbstractList[_T]']:
        """
        Group streams
        """
        tmp = {}
        for key, group in groupby(self, key=func):
            if key in tmp:
                tmp[key].extend(_AbstractList(iterable=group))
            else:
                tmp[key] = _AbstractList(iterable=group)
        return tmp

    def to_dict(self, k: Callable[[_T], _K], v: Callable[[_T], _V], overwrite: bool = True) -> Dict[_K, _V]:
        """
        Converts the stream into a dictionary
        :param k: Generate dictionary keys
        :param v: Generate the dictionary value
        :param overwrite: Whether to override when present
        """
        tmp = {}
        for i in self:
            key = k(i)
            value = v(i)
            if overwrite:
                tmp[key] = value
            else:
                if key not in tmp:
                    tmp[key] = value
        return tmp

    def get(self, index: int) -> Optional[_T]:
        """
        Gets the element that specifies the subscript
        :param index:
        :return:
        """
        if 0 <= index <= self.size():
            return self[index]
        return None

    def size(self) -> Integer:
        """
        return arraylist length
        """
        return Integer(len(self))


__all__ = [_AbstractList]
