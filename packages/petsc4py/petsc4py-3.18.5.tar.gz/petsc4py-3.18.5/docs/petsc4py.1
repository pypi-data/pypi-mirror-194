.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "PETSC4PY" "1" "Feb 27, 2023" "3.1" "PETSc for Python"
.SH NAME
petsc4py \- PETSc for Python
.INDENT 0.0
.TP
.B Author
Lisandro Dalcin
.TP
.B Contact
\fI\%dalcinl@gmail.com\fP
.TP
.B Web Site
\fI\%https://gitlab.com/petsc/petsc\fP
.TP
.B Date
Feb 27, 2023
.UNINDENT
.SS Abstract
.sp
This document describes \fI\%petsc4py\fP, a \fI\%Python\fP port to the \fI\%PETSc\fP
libraries.
.sp
\fI\%PETSc\fP (the Portable, Extensible Toolkit for Scientific
Computation) is a suite of data structures and routines for the
scalable (parallel) solution of scientific applications modeled by
partial differential equations. It employs the \fI\%MPI\fP standard for
all message\-passing communication.
.sp
This package provides an important subset of PETSc functionalities
and uses \fI\%NumPy\fP to efficiently manage input and output of array data.
.sp
A \fIgood friend\fP of petsc4py is:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%mpi4py\fP: Python bindings for \fI\%MPI\fP,
the \fIMessage Passing Interface\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Other projects depends on petsc4py:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%slepc4py\fP: Python bindings for \fI\%SLEPc\fP,
the \fIScalable Library for Eigenvalue Problem Computations\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.SH CONTENTS
.SS Overview
.sp
\fI\%PETSc\fP is a suite of data structures and routines for the
scalable (parallel) solution of scientific applications modeled by
partial differential equations. It employs the \fI\%MPI\fP standard for all
message\-passing communication.
.sp
PETSc is intended for use in large\-scale application projects
\fI\%[petsc\-efficient]\fP, and several ongoing computational science projects
are built around the PETSc libraries. With strict attention to
component interoperability, PETSc facilitates the integration of
independently developed application modules, which often most
naturally employ different coding styles and data structures.
.sp
PETSc is easy to use for beginners \fI\%[petsc\-user\-ref]\fP\&. Moreover, its
careful design allows advanced users to have detailed control over the
solution process. PETSc includes an expanding suite of parallel linear
and nonlinear equation solvers that are easily used in application
codes written in C, C++, and Fortran. PETSc provides many of the
mechanisms needed within parallel application codes, such as simple
parallel matrix and vector assembly routines that allow the overlap of
communication and computation.
.IP [petsc-user-ref] 5
S. Balay, S. Abhyankar, M. Adams, S. Benson, J. Brown,
P. Brune, K. Buschelman, E. Constantinescu, L. Dalcin, A. Dener,
V. Eijkhout, J. Faibussowitsch, W. Gropp, V. Hapla, T. Isaac, P. Jolivet,
D. Karpeyev, D. Kaushik, M. Knepley, F. Kong, S. Kruger,
D. May, L. Curfman McInnes, R. Mills, L. Mitchell, T. Munson,
J. Roman, K. Rupp, P. Sanan, J Sarich, B. Smith,
S. Zampini, H. Zhang, and H. Zhang, J. Zhang,
\fIPETSc/TAO Users Manual\fP, ANL\-21/39 \- Revision 3.18, 2022.
\fI\%https://petsc.org/release/docs/manual/manual.pdf\fP
.IP [petsc-efficient] 5
Satish Balay, Victor Eijkhout, William D. Gropp,
Lois Curfman McInnes and Barry F. Smith. Efficient Management of
Parallelism in Object Oriented Numerical Software Libraries. Modern
Software Tools in Scientific Computing. E. Arge, A. M. Bruaset and
H. P. Langtangen, editors. 163–202. Birkhauser Press. 1997.
.SS Components
.sp
PETSc is designed with an object\-oriented style. Almost all
user\-visible types are abstract interfaces with implementations that
may be chosen at runtime. Those objects are managed through handles to
opaque data structures which are created, accessed and destroyed by
calling appropriate library routines.
.sp
PETSc consists of a variety of components. Each component manipulates
a particular family of objects and the operations one would like to
perform on these objects. These components provide the functionality
required for many parallel solutions of PDEs.
.INDENT 0.0
.TP
.B Vec
Provides the vector operations required for setting up and
solving large\-scale linear and nonlinear problems. Includes
easy\-to\-use parallel scatter and gather operations, as well as
special\-purpose code for handling ghost points for regular data
structures.
.TP
.B Mat
A large suite of data structures and code for the manipulation
of parallel sparse matrices. Includes four different parallel
matrix data structures, each appropriate for a different class
of problems.
.TP
.B PC
A collection of sequential and parallel preconditioners,
including (sequential) ILU(k), LU, and (both sequential and
parallel) block Jacobi, overlapping additive Schwarz methods
and (through BlockSolve95) ILU(0) and ICC(0).
.TP
.B KSP
Parallel implementations of many popular Krylov subspace
iterative methods, including GMRES, CG, CGS, Bi\-CG\-Stab, two
variants of TFQMR, CR, and LSQR. All are coded so that they are
immediately usable with any preconditioners and any matrix data
structures, including matrix\-free methods.
.TP
.B SNES
Data\-structure\-neutral implementations of Newton\-like methods
for nonlinear systems. Includes both line search and trust
region techniques with a single interface. Employs by default
the above data structures and linear solvers. Users can set
custom monitoring routines, convergence criteria, etc.
.TP
.B TS
Code for the time evolution of solutions of PDEs. In addition,
provides pseudo\-transient continuation techniques for computing
steady\-state solutions.
.UNINDENT
.SS Installation
.SS Using \fBpip\fP
.sp
You can use \fBpip\fP to install \fBpetsc4py\fP and its
dependencies (\fBmpi4py\fP is optional but highly recommended):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python \-m pip install [\-\-user] numpy mpi4py  (or pip install [\-\-user] numpy mpi4py)
$ python \-m pip install [\-\-user] petsc petsc4py (or pip install [\-\-user] petsc petsc4py)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Using \fBsetuptools\fP
.sp
You can also install dependencies manually and then invoke setuptools
from the \fIpetsc4py\fP source directory:
.INDENT 0.0
.INDENT 3.5
$ python setup.py build
$ python setup.py install
.UNINDENT
.UNINDENT
.sp
You may use the \fI–install\-lib\fP argument to the \fIinstall\fP command to alter the
\fIsite\-packages\fP directory where the package is to be installed.
.sp
If you are cross\-compiling, and the \fInumpy\fP module cannot be loaded on your
build host, then before invoking \fIsetup.py\fP, set \fINUMPY_INCLUDE\fP environment
variable to the path that would be returned by \fIimport numpy;
numpy.get_include()\fP:
.INDENT 0.0
.INDENT 3.5
$ export NUMPY_INCLUDE=/usr/lib/pythonX/site\-packages/numpy/core/include
.UNINDENT
.UNINDENT
.SS From PETSc source
.sp
If you already have downloaded PETSc source and have installed the dependencies
of \fIpetsc4py\fP, then to build the \fIpetsc4py\fP module along with PETSc, add the
\fI–with\-petsc4py=1\fP argument to the configure command when building PETSc:
.INDENT 0.0
.INDENT 3.5
$ ./configure –with\-petsc4py=1
$ make
$ make install
.UNINDENT
.UNINDENT
.sp
This will install PETSc and the \fIpetsc4py\fP module into the PETSc directory
under the prefix specified to the PETSc configure command.
.sp
If you wish to make the module importable without having to set the
\fIPYTHONPATH\fP environment variable, you may add a shortcut to the system\-wide
\fIsite\-packages\fP directory creating a special \fI\&.pth\fP file with exactly one line
of Python code. This can be done by the following command, where the
system\-wide path is assumed to be \fI/usr/lib/pythonX/site\-packages\fP (replace \fIX\fP
with your python version):
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B $ echo 
“import sys, os;” “p = os.getenv(‘PETSC_DIR’);” “a = os.getenv(‘PETSC_ARCH’) or ‘’;” “p = p and os.path.join(p, a, ‘lib’);” “p and (p in sys.path or sys.path.append(p))” > /usr/lib/pythonX/site\-packages/petsc4py.pth
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If you are cross\-compiling, and \fInumpy\fP cannot be loaded on your build host,
then pass \fI–have\-numpy=1 –with\-numpy\-include=PATH\fP, where \fIPATH\fP is the path
that would be returned by \fIimport numpy; print(numpy.get_include())\fP\&. This will
suppress autodetection of the include path on the build host.
.SS Tutorial
.sp
XXX To be written … Any contribution welcome!
.SS Citations
.sp
If PETSc for Python been significant to a project that leads to an
academic publication, please acknowledge that fact by citing the
project.
.INDENT 0.0
.IP \(bu 2
L. Dalcin, P. Kler, R. Paz, and A. Cosimo,
\fIParallel Distributed Computing using Python\fP,
Advances in Water Resources, 34(9):1124\-1139, 2011.
\fI\%http://dx.doi.org/10.1016/j.advwatres.2011.04.013\fP
.IP \(bu 2
S. Balay, S. Abhyankar, M. Adams, S. Benson, J. Brown,
P. Brune, K. Buschelman, E. Constantinescu, L. Dalcin, A. Dener,
V. Eijkhout, J. Faibussowitsch, W. Gropp, V. Hapla, T. Isaac, P. Jolivet,
D. Karpeyev, D. Kaushik, M. Knepley, F. Kong, S. Kruger,
D. May, L. Curfman McInnes, R. Mills, L. Mitchell, T. Munson,
J. Roman, K. Rupp, P. Sanan, J Sarich, B. Smith,
S. Zampini, H. Zhang, and H. Zhang, J. Zhang,
\fIPETSc/TAO Users Manual\fP, ANL\-21/39 \- Revision 3.18, 2022.
\fI\%https://petsc.org/release/docs/manual/manual.pdf\fP
.UNINDENT
.SH AUTHOR
Lisandro Dalcin
.SH COPYRIGHT
2021, Lisandro Dalcin
.\" Generated by docutils manpage writer.
.
